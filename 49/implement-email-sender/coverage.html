
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">dashboard-ecommerce-team2/config/config.go (75.0%)</option>
				
				<option value="file1">dashboard-ecommerce-team2/controller/banner/banner_controller.go (52.5%)</option>
				
				<option value="file2">dashboard-ecommerce-team2/controller/category/category_controller.go (1.3%)</option>
				
				<option value="file3">dashboard-ecommerce-team2/controller/controller.go (100.0%)</option>
				
				<option value="file4">dashboard-ecommerce-team2/controller/dashboard/dashboard_controller.go (73.1%)</option>
				
				<option value="file5">dashboard-ecommerce-team2/controller/order/order_controller.go (1.2%)</option>
				
				<option value="file6">dashboard-ecommerce-team2/controller/product/product_controller.go (1.2%)</option>
				
				<option value="file7">dashboard-ecommerce-team2/controller/promotion/promotion_controller.go (1.7%)</option>
				
				<option value="file8">dashboard-ecommerce-team2/controller/stock/stock_controller.go (3.0%)</option>
				
				<option value="file9">dashboard-ecommerce-team2/controller/user/user_controller.go (66.0%)</option>
				
				<option value="file10">dashboard-ecommerce-team2/database/database.go (17.9%)</option>
				
				<option value="file11">dashboard-ecommerce-team2/database/migration.go (0.0%)</option>
				
				<option value="file12">dashboard-ecommerce-team2/database/redis.go (14.8%)</option>
				
				<option value="file13">dashboard-ecommerce-team2/database/seeder.go (0.0%)</option>
				
				<option value="file14">dashboard-ecommerce-team2/docs/docs.go (0.0%)</option>
				
				<option value="file15">dashboard-ecommerce-team2/helper/bcrypt.go (100.0%)</option>
				
				<option value="file16">dashboard-ecommerce-team2/helper/contains.go (0.0%)</option>
				
				<option value="file17">dashboard-ecommerce-team2/helper/getUrlImage.go (0.0%)</option>
				
				<option value="file18">dashboard-ecommerce-team2/helper/logger.go (80.0%)</option>
				
				<option value="file19">dashboard-ecommerce-team2/helper/pointerToTime.go (0.0%)</option>
				
				<option value="file20">dashboard-ecommerce-team2/helper/response.go (66.7%)</option>
				
				<option value="file21">dashboard-ecommerce-team2/helper/token.go (0.0%)</option>
				
				<option value="file22">dashboard-ecommerce-team2/helper/validator.go (0.0%)</option>
				
				<option value="file23">dashboard-ecommerce-team2/infra/context.go (0.0%)</option>
				
				<option value="file24">dashboard-ecommerce-team2/main.go (0.0%)</option>
				
				<option value="file25">dashboard-ecommerce-team2/middleware/authentication.go (2.8%)</option>
				
				<option value="file26">dashboard-ecommerce-team2/models/banner.go (0.0%)</option>
				
				<option value="file27">dashboard-ecommerce-team2/models/category.go (0.0%)</option>
				
				<option value="file28">dashboard-ecommerce-team2/models/order.go (0.0%)</option>
				
				<option value="file29">dashboard-ecommerce-team2/models/product.go (0.0%)</option>
				
				<option value="file30">dashboard-ecommerce-team2/models/promotion.go (0.0%)</option>
				
				<option value="file31">dashboard-ecommerce-team2/models/user.go (0.0%)</option>
				
				<option value="file32">dashboard-ecommerce-team2/repository/category/category_repository.go (3.0%)</option>
				
				<option value="file33">dashboard-ecommerce-team2/repository/order/order_repository.go (1.7%)</option>
				
				<option value="file34">dashboard-ecommerce-team2/repository/order/order_repository_mock.go (0.0%)</option>
				
				<option value="file35">dashboard-ecommerce-team2/repository/product/product_repository.go (1.5%)</option>
				
				<option value="file36">dashboard-ecommerce-team2/repository/product/product_repository_mock.go (0.0%)</option>
				
				<option value="file37">dashboard-ecommerce-team2/repository/promotion/promotion_repository.go (2.6%)</option>
				
				<option value="file38">dashboard-ecommerce-team2/repository/repository.go (100.0%)</option>
				
				<option value="file39">dashboard-ecommerce-team2/repository/stock/stock_repository.go (2.0%)</option>
				
				<option value="file40">dashboard-ecommerce-team2/repository/user/user_repository.go (7.7%)</option>
				
				<option value="file41">dashboard-ecommerce-team2/repository/user/user_repository_mock.go (80.0%)</option>
				
				<option value="file42">dashboard-ecommerce-team2/routes/route.go (0.0%)</option>
				
				<option value="file43">dashboard-ecommerce-team2/service/category/category_service.go (3.6%)</option>
				
				<option value="file44">dashboard-ecommerce-team2/service/dashboard/dashboard_service.go (1.7%)</option>
				
				<option value="file45">dashboard-ecommerce-team2/service/dashboard/dashboard_service_mock.go (80.0%)</option>
				
				<option value="file46">dashboard-ecommerce-team2/service/order/order_service.go (2.2%)</option>
				
				<option value="file47">dashboard-ecommerce-team2/service/product/product_service.go (2.7%)</option>
				
				<option value="file48">dashboard-ecommerce-team2/service/promotion/promotion_service.go (16.7%)</option>
				
				<option value="file49">dashboard-ecommerce-team2/service/service.go (100.0%)</option>
				
				<option value="file50">dashboard-ecommerce-team2/service/stock/stock_service.go (8.3%)</option>
				
				<option value="file51">dashboard-ecommerce-team2/service/user/user_service.go (91.7%)</option>
				
				<option value="file52">dashboard-ecommerce-team2/service/user/user_service_mock.go (0.0%)</option>
				
				<option value="file53">dashboard-ecommerce-team2/util/mocks.go (0.0%)</option>
				
				<option value="file54">dashboard-ecommerce-team2/util/uploadCDN.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "dashboard-ecommerce-team2/helper"
        "os"

        "github.com/joho/godotenv"
)

type Configuration struct {
        AppName     string
        Debug       bool
        Port        string
        SecretKey   string
        MigrateUsed bool
        DBConfig    DBConfig
        RedisConfig RedisConfig
}

type DBConfig struct {
        DBName         string
        DBUsername     string
        DBPassword     string
        DBHost         string
        DBTimeZone     string
        DBMaxIdleConns int
        DBMaxOpenConns int
        DBMaxIdleTime  int
        DBMaxLifeTime  int
}

type RedisConfig struct {
        Url      string
        Password string
        Prefix   string
}

func ReadConfig() (Configuration, error) <span class="cov8" title="1">{
        err := godotenv.Load()
        if err != nil </span><span class="cov8" title="1">{
                return Configuration{}, err
        }</span>
        <span class="cov0" title="0">return Configuration{
                AppName:     os.Getenv("APP_NAME"),
                Debug:       helper.StringToBool(os.Getenv("DEBUG")),
                Port:        os.Getenv("PORT"),
                SecretKey:   os.Getenv("SECRET_KEY"),
                MigrateUsed: helper.StringToBool(os.Getenv("MIGRATE_USED")),
                DBConfig: DBConfig{
                        DBName:         os.Getenv("DB_NAME"),
                        DBUsername:     os.Getenv("DB_USERNAME"),
                        DBPassword:     os.Getenv("DB_PASSWORD"),
                        DBHost:         os.Getenv("DB_HOST"),
                        DBTimeZone:     os.Getenv("DB_TIMEZONE"),
                        DBMaxIdleConns: helper.StringToInt(os.Getenv("DB_MAX_IDLE_CONNS")),
                        DBMaxOpenConns: helper.StringToInt(os.Getenv("DB_MAX_OPEN_CONNS")),
                        DBMaxIdleTime:  helper.StringToInt(os.Getenv("DB_MAX_IDLE_TIME")),
                        DBMaxLifeTime:  helper.StringToInt(os.Getenv("DB_MAX_LIFE_TIME")),
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package bannercontroller

import (
        "dashboard-ecommerce-team2/helper"
        "dashboard-ecommerce-team2/models"
        "dashboard-ecommerce-team2/service"
        "log"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type BannerController struct {
        Service service.Service
        Log     *zap.Logger
}

func NewBannerController(service service.Service, log *zap.Logger) *BannerController <span class="cov8" title="1">{
        return &amp;BannerController{
                Service: service,
                Log:     log,
        }
}</span>

// CreateBannerController godoc
// @Summary Create a new banner
// @Description Create a new banner with image upload
// @Tags Banner
// @Accept multipart/form-data
// @Produce json
// @Param title formData string true "Banner Title"
// @Param description formData string false "Banner Description"
// @Param image_path formData file true "Banner Image"
// @Success 200 {object} models.SuccessResponse{data=models.Banner} "Successfully created banner"
// @Failure 400 {object} models.ErrorResponse "Invalid data input"
// @Failure 500 {object} models.ErrorResponse "Failed to upload image or create banner"
// @Router /api/create-banner [post]
func (ctrl *BannerController) CreateBannerController(c *gin.Context) <span class="cov8" title="1">{
        var banner models.BannerGetValue

        // Bind the form data to the banner struct (without the file)
        if err := c.ShouldBind(&amp;banner); err != nil </span><span class="cov8" title="1">{
                helper.ResponseError(c, "INVALID", "invalid data input", http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        // Process image upload
        <span class="cov0" title="0">imageURL, err := helper.UploadImage(banner.ImagePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
                helper.ResponseError(c, "FAILED", "Failed to upload image", http.StatusInternalServerError)
                return
        }</span>

        // Assign the image URL to the banner
        <span class="cov0" title="0">var bannerSave models.Banner
        bannerSave, err = bannerSave.CopyBannerGetValueToBanner(imageURL, banner)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error binding form data:", err.Error())
                helper.ResponseError(c, "INVALID", "invalid data input", http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        // Call service to create the banner
        <span class="cov0" title="0">if err := ctrl.Service.Banner.CreateBanner(&amp;bannerSave); err != nil </span><span class="cov0" title="0">{
                helper.ResponseError(c, "FAILED", "Failed to create banner", http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, bannerSave, "Successfully created banner", http.StatusOK)</span>
}

// UpdateBannerController godoc
// @Summary Update banner published status
// @Description Toggle the published status of a banner
// @Tags Banner
// @Accept multipart/form-data
// @Produce json
// @Param id formData int true "Banner ID"
// @Success 200 {object} models.SuccessResponse{data=models.Banner} "Successfully updated published banner"
// @Failure 400 {object} models.ErrorResponse "Invalid banner ID"
// @Failure 500 {object} models.ErrorResponse "Failed to update banner"
// @Router /api/banner [put]
func (ctrl *BannerController) UpdateBannerController(c *gin.Context) <span class="cov8" title="1">{
        id := c.Request.FormValue("id")
        idInt, err := strconv.Atoi(id)
        if err != nil </span><span class="cov8" title="1">{
                helper.ResponseError(c, "FAILED", "id banner invalid", http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        // banner, err := ctrl.Service.Banner.GetBannerByID(idInt)
        // if err != nil {
        //         helper.ResponseError(c, "FAILED", err.Error(), http.StatusInternalServerError)
        //         c.Abort()
        //         return
        // }

        // change status publish
        // banner.Published = !banner.Published

        <span class="cov8" title="1">var banner models.Banner
        banner.ID = idInt
        err = ctrl.Service.Banner.UpdateBanner(&amp;banner)
        if err != nil </span><span class="cov0" title="0">{
                helper.ResponseError(c, "FAILED", err.Error(), http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, banner, "Successfully update published banner", http.StatusOK)</span>
}

// GetBannerByIDController godoc
// @Summary Get banner by ID
// @Description Retrieve a specific banner by its ID
// @Tags Banner
// @Accept multipart/form-data
// @Produce json
// @Param id formData int true "Banner ID"
// @Success 200 {object} models.SuccessResponse{data=models.Banner} "Successfully retrieved banner"
// @Failure 400 {object} models.ErrorResponse "Invalid banner ID"
// @Failure 500 {object} models.ErrorResponse "Failed to retrieve banner"
// @Router /api/banner [get]
func (ctrl *BannerController) GetBannerByIDController(c *gin.Context) <span class="cov8" title="1">{
        id := c.Request.FormValue("id")
        idInt, err := strconv.Atoi(id)
        if err != nil </span><span class="cov8" title="1">{
                helper.ResponseError(c, "FAILED", "id banner invalid", http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">banner, err := ctrl.Service.Banner.GetBannerByID(idInt)
        if err != nil </span><span class="cov0" title="0">{
                helper.ResponseError(c, "FAILED", err.Error(), http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, banner, "Successfully get banner", http.StatusOK)</span>
}

// DeleteBannerController godoc
// @Summary Delete a banner
// @Description Remove a banner by its ID
// @Tags Banner
// @Accept multipart/form-data
// @Produce json
// @Security ApiKeyAuth
// @Param Authorization header string true "Role"
// @Param id formData int true "Banner ID"
// @Success 200 {object} models.SuccessResponse "Successfully deleted banner"
// @Failure 400 {object} models.ErrorResponse "Invalid banner ID"
// @Failure 500 {object} models.ErrorResponse "Failed to delete banner"
// @Router /api/banner [delete]
func (ctrl *BannerController) DeleteBannerController(c *gin.Context) <span class="cov8" title="1">{
        id := c.Request.FormValue("id")
        idInt, err := strconv.Atoi(id)
        if err != nil </span><span class="cov8" title="1">{
                helper.ResponseError(c, "FAILED", "id banner invalid", http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">err = ctrl.Service.Banner.DeleteBanner(idInt)
        if err != nil </span><span class="cov0" title="0">{
                helper.ResponseError(c, "FAILED", err.Error(), http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, nil, "Successfully delete banner", http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package categorycontroller

import (
        "dashboard-ecommerce-team2/helper"
        "dashboard-ecommerce-team2/models"
        "dashboard-ecommerce-team2/service"
        utils "dashboard-ecommerce-team2/util"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type CategoryController struct {
        Service service.Service
        Log     *zap.Logger
}

func NewCategoryController(service service.Service, log *zap.Logger) *CategoryController <span class="cov8" title="1">{
        return &amp;CategoryController{
                Service: service,
                Log:     log,
        }
}</span>

// CreateCategoryController godoc
// @Summary Create a new category
// @Description Create a new category with a name
// @Tags Categories
// @Accept json
// @Produce json
// @Param category body models.Category true "Category name"
// @Success 201 {object} helper.HTTPResponse "Successfully created the category"
// @Failure 400 {object} helper.HTTPResponse "Invalid input"
// @Failure 500 {object} helper.HTTPResponse "Failed to create category"
// @Router /category/create [post]
func (ctrl *CategoryController) CreateCatergoryController(c *gin.Context) <span class="cov0" title="0">{
        var categoryInput models.Category
        file, err := c.FormFile("icon")
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Failed to get uploaded file", zap.Error(err))
                helper.ResponseError(c, err.Error(), "File upload required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">filePath := "./temp/" + file.Filename
        if err := c.SaveUploadedFile(file, filePath); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Failed to save uploaded file", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Failed to process file", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">iconURL, err := utils.UploadToCDN(filePath)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Failed to upload file to CDN", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Failed to upload to CDN", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">categoryInput.Icon = iconURL

        if err := ctrl.Service.Category.CreateCatergory(categoryInput); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Failed to create category", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Failed to create category", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, categoryInput, "Category created successfully", http.StatusCreated)</span>
}

// GetAllCategoriesController godoc
// @Summary Get all categories
// @Description Retrieve all categories with pagination
// @Tags Categories
// @Accept json
// @Produce json
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Number of items per page" default(10)
// @Success 200 {object} helper.HTTPResponse "List of categories"
// @Router /category/list [get]
func (ctrl *CategoryController) GetAllCategoriesController(c *gin.Context) <span class="cov0" title="0">{
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        limit, _ := strconv.Atoi(c.DefaultQuery("limit", "10"))

        limitInt64 := int64(limit)

        categories, totalItems, err := ctrl.Service.Category.GetAllCategories(page, limit)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Failed to fetch categories", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Failed to fetch categories", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">totalPages := (totalItems + limitInt64 - 1) / limitInt64
        helper.ResponseOKPagination(c, categories, "Categories fetched successfully", page, limit, int(totalItems), int(totalPages), http.StatusOK)</span>
}

// GetCategoryByIDController godoc
// @Summary Get category by ID
// @Description Retrieve a category by its ID
// @Tags Categories
// @Accept json
// @Produce json
// @Param id path int true "Category ID"
// @Success 200 {object} models.Category "Category data"
// @Failure 400 {object} helper.HTTPResponse "Invalid category ID"
// @Failure 404 {object} helper.HTTPResponse "Category not found"
// @Router /category/:id [get]
func (ctrl *CategoryController) GetCategoryByIDController(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Invalid category ID", zap.Error(err))
                helper.ResponseError(c, "Invalid ID format", "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">category, err := ctrl.Service.Category.GetCategoryByID(id)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Failed to fetch category by ID", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Category not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, category, "Category fetched successfully", http.StatusOK)</span>
}

// UpdateCategoryController godoc
// @Summary Update a category
// @Description Update the details of an existing category by ID
// @Tags categories
// @Accept json
// @Produce json
// @Param id path int true "Category ID"
// @Param body body models.Category true "Updated category details"
// @Success 200 {object} helper.HTTPResponse "Successfully updated the category"
// @Failure 400 {object} helper.HTTPResponse "Invalid category ID or input"
// @Failure 404 {object} helper.HTTPResponse "Category not found"
// @Failure 500 {object} helper.HTTPResponse "Failed to update category"
// @Router /category/:id [put]
func (ctrl *CategoryController) UpdateCategoryController(c *gin.Context) <span class="cov0" title="0">{
        var categoryInput models.Category
        if err := c.ShouldBind(&amp;categoryInput); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Failed to bind input", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">file, err := c.FormFile("icon")
        if err == nil </span><span class="cov0" title="0">{
                filePath := "./temp/" + file.Filename
                if err := c.SaveUploadedFile(file, filePath); err != nil </span><span class="cov0" title="0">{
                        ctrl.Log.Error("Failed to save uploaded file", zap.Error(err))
                        helper.ResponseError(c, err.Error(), "Failed to process file", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">iconURL, err := utils.UploadToCDN(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        ctrl.Log.Error("Failed to upload file to CDN", zap.Error(err))
                        helper.ResponseError(c, err.Error(), "Failed to upload to CDN", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">categoryInput.Icon = iconURL</span>
        }

        <span class="cov0" title="0">if err := ctrl.Service.Category.UpdateCategory(categoryInput); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Failed to update category", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Failed to update category", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, categoryInput, "Category updated successfully", http.StatusOK)</span>
}

// DeleteCategoryController godoc
// @Summary Delete category by ID
// @Description Delete a category by its ID
// @Tags Categories
// @Accept json
// @Produce json
// @Param id path int true "Category ID"
// @Success 200 {object} helper.HTTPResponse "Successfully deleted the category"
// @Failure 400 {object} helper.HTTPResponse "Invalid category ID"
// @Failure 500 {object} helper.HTTPResponse "Failed to delete category"
// @Router /category/:id [delete]
func (ctrl *CategoryController) DeleteCategoryController(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Invalid category ID", zap.Error(err))
                helper.ResponseError(c, "Invalid ID format", "Invalid input", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := ctrl.Service.Category.DeleteCategory(id); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Failed to delete category", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Failed to delete category", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, nil, "Category deleted successfully", http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        "dashboard-ecommerce-team2/config"
        bannercontroller "dashboard-ecommerce-team2/controller/banner"
        categorycontroller "dashboard-ecommerce-team2/controller/category"
        dashboardcontroller "dashboard-ecommerce-team2/controller/dashboard"
        ordercontroller "dashboard-ecommerce-team2/controller/order"
        productcontroller "dashboard-ecommerce-team2/controller/product"
        promotioncontroller "dashboard-ecommerce-team2/controller/promotion"
        stockcontroller "dashboard-ecommerce-team2/controller/stock"
        usercontroller "dashboard-ecommerce-team2/controller/user"
        "dashboard-ecommerce-team2/database"
        "dashboard-ecommerce-team2/service"

        "go.uber.org/zap"
)

type Controller struct {
        Banner    bannercontroller.BannerController
        Category  categorycontroller.CategoryController
        Dashboard dashboardcontroller.DashboardController
        Order     ordercontroller.OrderController
        Product   productcontroller.ProductController
        Promotion promotioncontroller.PromotionController
        Stock     stockcontroller.StockController
        User      usercontroller.UserController
}

func NewController(service service.Service, logger *zap.Logger, cacher database.Cacher, config config.Configuration) *Controller <span class="cov8" title="1">{
        return &amp;Controller{
                Banner:    *bannercontroller.NewBannerController(service, logger),
                Category:  *categorycontroller.NewCategoryController(service, logger),
                Dashboard: *dashboardcontroller.NewDashboardController(service, logger),
                Order:     *ordercontroller.NewOrderController(service, logger),
                Product:   *productcontroller.NewProductController(service, logger),
                Promotion: *promotioncontroller.NewPromotionController(service, logger),
                Stock:     *stockcontroller.NewStockController(service, logger),
                User:      *usercontroller.NewUserController(service, logger, cacher, config),
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package dashboardcontroller

import (
        "dashboard-ecommerce-team2/helper"
        "dashboard-ecommerce-team2/service"
        "net/http"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type DashboardController struct {
        Service service.Service
        Log     *zap.Logger
}

func NewDashboardController(service service.Service, log *zap.Logger) *DashboardController <span class="cov0" title="0">{
        return &amp;DashboardController{
                Service: service,
                Log:     log,
        }
}</span>

// @Summary Get dashboard summary
// @Description Retrieve a summary of the dashboard
// @Tags Dashboard
// @Produce json
// @Success 200 {object} helper.HTTPResponse "dashboard summary successfully retrieved"
// @Failure 500 {object} helper.HTTPResponse "Error getting summary"
// @Router /dashboard/summary [get]
func (ctrl *DashboardController) GetSummaryController(c *gin.Context) <span class="cov8" title="1">{
        summary, err := ctrl.Service.Dashboard.GetDashboardSummary()
        if err != nil </span><span class="cov8" title="1">{
                ctrl.Log.Error("Error getting summary", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Error getting summary", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">helper.ResponseOK(c, summary, "dashboard summary successfully retrieved", http.StatusOK)</span>
}

// @Summary Get current month earnings
// @Description Retrieve the earnings for the current month
// @Tags Dashboard
// @Produce json
// @Success 200 {object} helper.HTTPResponse "current month earnings successfully retrieved"
// @Failure 500 {object} helper.HTTPResponse"Error getting earnings"
// @Router /dashboard/current-month-earning [get]
func (ctrl *DashboardController) CurrentMonthEarningController(c *gin.Context) <span class="cov8" title="1">{
        earnings, err := ctrl.Service.Dashboard.CurrentMonthEarning()
        if err != nil </span><span class="cov8" title="1">{
                ctrl.Log.Error("Error getting current month earning", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Error getting current month earning", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">helper.ResponseOK(c, earnings, "current month earnings successfully retrieved", http.StatusOK)</span>
}

// @Summary Get revenue chart
// @Description Generate a revenue chart for the dashboard
// @Tags Dashboard
// @Produce text/html
// @Success 200 {string} string "&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset='utf-8'&gt;&lt;title&gt;Awesome go-echarts&lt;/title&gt;&lt;script src='https://go-echarts.github.io/go-echarts-assets/assets/echarts.min.js'&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class='container'&gt;&lt;div class='item' id='PvBdsRyYJxot' style='width:900px;height:500px;'&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type='text/javascript'&gt;\"use strict\";let goecharts_PvBdsRyYJxot = echarts.init(document.getElementById('PvBdsRyYJxot'), 'white', { renderer: 'canvas' });let option_PvBdsRyYJxot = {\"color\":[\"#5470c6\",\"#91cc75\",\"#fac858\",\"#ee6666\",\"#73c0de\",\"#3ba272\",\"#fc8452\",\"#9a60b4\",\"#ea7ccc\"],\"legend\":{},\"series\":[{\"name\":\"Revenue\",\"type\":\"line\",\"smooth\":true,\"data\":[{\"value\":150.75},{\"value\":300},{\"value\":500.5},{\"value\":175.25},{\"value\":250},{\"value\":100.75},{\"value\":400.5},{\"value\":300.25},{\"value\":275},{\"value\":125.5},{\"value\":500},{\"value\":350}]}],\"title\":{\"text\":\"Monthly Revenue\"},\"toolbox\":{},\"tooltip\":{},\"xAxis\":[{\"name\":\"Month\",\"data\":[\"January  \",\"February \",\"March    \",\"April    \",\"May      \",\"June     \",\"July     \",\"August   \",\"September\",\"October  \",\"November \",\"December \"]}],\"yAxis\":[{\"name\":\"Revenue\"}]}goecharts_PvBdsRyYJxot.setOption(option_PvBdsRyYJxot);&lt;/script&gt;&lt;style&gt;.container {margin-top:30px; display: flex;justify-content: center;align-items: center;}.item {margin: auto;}&lt;/style&gt;&lt;/body&gt;&lt;/html&gt;"
// @Failure 500 {object} helper.HTTPResponse "Error generating revenue chart"
// @Router /dashboard/revenue-chart [get]
func (ctrl *DashboardController) RenevueChartController(c *gin.Context) <span class="cov8" title="1">{
        revenueChart, err := ctrl.Service.Dashboard.GenerateRenevueChart()
        if err != nil </span><span class="cov8" title="1">{
                ctrl.Log.Error("Error generating revenue chart", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Error generating revenue chart", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">c.Header("Content-Type", "text/html")
        c.Writer.Write(revenueChart.Bytes())</span>
}

// @Summary Get best product list
// @Description Retrieve a list of the best-selling products
// @Tags Dashboard
// @Produce json
// @Success 200 {object} helper.HTTPResponse "best product list successfully retrieved"
// @Failure 500 {object} helper.HTTPResponse "Error getting best product list"
// @Router /dashboard/best-item-list [get]
func (ctrl *DashboardController) GetBestProductListController(c *gin.Context) <span class="cov0" title="0">{
        bestProduct, err := ctrl.Service.Dashboard.GetBestItemList()
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Error getting best product list", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Error getting best product list", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">helper.ResponseOK(c, bestProduct, "best product list successfully retrieved", http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package ordercontroller

import (
        "dashboard-ecommerce-team2/helper"
        "dashboard-ecommerce-team2/models"
        "dashboard-ecommerce-team2/service"
        "math"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type OrderController struct {
        Service service.Service
        Log     *zap.Logger
}

func NewOrderController(service service.Service, log *zap.Logger) *OrderController <span class="cov8" title="1">{
        return &amp;OrderController{
                Service: service,
                Log:     log,
        }
}</span>

// UpdateOrderStatusController godoc
// @Summary Update order status
// @Description Update the status of an order by ID
// @Tags Orders
// @Accept json
// @Produce json
// @Param id path int true "Order ID"
// @Param status body string true "Order Status" example("shipped")
// @Success 200 {object} helper.HTTPResponse "Successfully updated the order status"
// @Failure 400 {object} helper.HTTPResponse "Invalid order ID"
// @Failure 500 {object} helper.HTTPResponse "Failed to update order status"
// @Router /orders/{id} [put]
func (ctrl *OrderController) UpdateOrderStatusController(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        ctrl.Log.Info("Received ID from URL", zap.String("id", idStr))

        if idStr == "" </span><span class="cov0" title="0">{
                ctrl.Log.Error("Invalid order ID: ID cannot be empty")
                helper.ResponseError(c, "Invalid order ID", "Invalid order ID", 400)
                return
        }</span>

        <span class="cov0" title="0">id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Invalid order ID format", zap.String("id", idStr), zap.Error(err))
                helper.ResponseError(c, "Invalid order ID", "Invalid order ID", 400)
                return
        }</span>

        <span class="cov0" title="0">var statusRequest struct {
                Status string `json:"status" binding:"required"`
        }

        if err := c.BindJSON(&amp;statusRequest); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Invalid input", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Invalid input", 400)
                return
        }</span>

        <span class="cov0" title="0">if err := ctrl.Service.Order.UpdateOrderStatus(id, statusRequest.Status); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Failed to update order status", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Failed to update order status", 500)
                return
        }</span>

        <span class="cov0" title="0">ctrl.Log.Info("Successfully updated order status", zap.Int("id", id), zap.String("status", statusRequest.Status))
        helper.ResponseOK(c, nil, "Order status updated successfully", 200)</span>
}

// GetAllOrdersController godoc
// @Summary Get all orders with pagination
// @Description Get a paginated list of orders
// @Tags orders
// @Accept json
// @Produce json
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Number of items per page" default(10)
// @Success 200 {object} helper.HTTPResponse
// @Router /orders/ [get]
func (ctrl *OrderController) GetAllOrdersController(c *gin.Context) <span class="cov0" title="0">{
        pageParam := c.DefaultQuery("page", "1")
        limitParam := c.DefaultQuery("limit", "10")

        page, err := strconv.Atoi(pageParam)
        if err != nil || page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">limit, err := strconv.Atoi(limitParam)
        if err != nil || limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">orders, totalItems, err := ctrl.Service.Order.GetAllOrders(page, limit)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Failed to fetch paginated orders", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Failed to fetch orders", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">totalPages := int(math.Ceil(float64(totalItems) / float64(limit)))

        helper.ResponseOKPagination(c, orders, "Fetched orders successfully", page, limit, int(totalItems), totalPages, http.StatusOK)</span>
}

// GetOrderByIDController godoc
// @Summary Get order by ID
// @Description Get a single order by ID
// @Tags orders
// @Accept json
// @Produce json
// @Param id path int true "Order ID"
// @Success 200 {object} models.Order
// @Router /orders/{id} [get]
func (ctrl *OrderController) GetOrderByIDController(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Invalid order ID", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Invalid order ID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">order, err := ctrl.Service.Order.GetOrderByID(id)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Failed to fetch order by ID", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Order not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, order, "Fetched order by ID successfully", http.StatusOK)</span>
}

// DeleteOrderController godoc
// @Summary Delete order by ID
// @Description Delete an order by ID
// @Tags orders
// @Accept json
// @Produce json
// @Param id path int true "Order ID"
// @Success 200 {object} helper.HTTPResponse "Successfully deleted the order"
// @Failure 400 {object} helper.HTTPResponse "Invalid order ID"
// @Failure 500 {object} helper.HTTPResponse "Failed to delete the order"
// @Router /orders/{id} [delete]
func (ctrl *OrderController) DeleteOrderController(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        ctrl.Log.Info("Received ID from URL", zap.String("id", idStr))

        if idStr == "" </span><span class="cov0" title="0">{
                ctrl.Log.Error("Invalid order ID: ID cannot be empty")
                helper.ResponseError(c, "Invalid order ID", "Invalid order ID", 400)
                return
        }</span>

        <span class="cov0" title="0">id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Invalid order ID format", zap.String("id", idStr), zap.Error(err))
                helper.ResponseError(c, "Invalid order ID", "Invalid order ID", 400)
                return
        }</span>

        <span class="cov0" title="0">err = ctrl.Service.Order.DeleteOrder(id)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Failed to delete order", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Failed to delete order", 500)
                return
        }</span>

        <span class="cov0" title="0">ctrl.Log.Info("Successfully deleted order", zap.Int("id", id))
        helper.ResponseOK(c, nil, "Order deleted successfully", 200)</span>
}

// GetOrderDetailController godoc
// @Summary Get order detail by ID
// @Description Get the details of an order by ID
// @Tags orders
// @Accept json
// @Produce json
// @Param id path int true "Order ID"
// @Success 200 {object} helper.HTTPResponse
// @Failure 400 {object} helper.HTTPResponse "Invalid order ID"
// @Failure 500 {object} helper.HTTPResponse "Failed to fetch order details"
// @Router /orders/detail/{id} [get]
func (ctrl *OrderController) GetOrderDetailController(c *gin.Context) <span class="cov0" title="0">{
        idStr := c.Param("id")
        ctrl.Log.Info("Received ID from URL", zap.String("id", idStr))

        if idStr == "" </span><span class="cov0" title="0">{
                ctrl.Log.Error("Invalid order ID: ID cannot be empty")
                helper.ResponseError(c, "Invalid order ID", "Invalid order ID", 400)
                return
        }</span>

        <span class="cov0" title="0">id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Invalid order ID format", zap.String("id", idStr), zap.Error(err))
                helper.ResponseError(c, "Invalid order ID", "Invalid order ID", 400)
                return
        }</span>

        <span class="cov0" title="0">order, orderItems, err := ctrl.Service.Order.GetOrderDetail(id)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Failed to fetch order details", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Failed to fetch order details", 500)
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, models.OrderDetailResponse{Order: order, Items: orderItems}, "Fetched order details successfully", http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package productcontroller

import (
        "dashboard-ecommerce-team2/helper"
        "dashboard-ecommerce-team2/models"
        "dashboard-ecommerce-team2/service"
        "net/http"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type ProductController struct {
        Service service.Service
        Log     *zap.Logger
}

func NewProductController(service service.Service, log *zap.Logger) *ProductController <span class="cov8" title="1">{
        return &amp;ProductController{
                Service: service,
                Log:     log,
        }
}</span>

// CreateProductController godoc
// @Summary Creates a new product
// @Description Create a new product with an image
// @Tags Product
// @Accept json
// @Produce json
// @Param category_id formData string true "Category ID"
// @Param name formData string true "Product Name"
// @Param code_product formData string true "Code Product"
// @Param description formData string true "Description Product"
// @Param price formData number true "Product Price"
// @Param stock formData int true "Product Stock"
// @Param image formData file true "Product Image"
// @Success 201 {object} utils.ResponseOK{data=models.Product} "Product created successfully"
// @Failure 400 {object} utils.ErrorResponse "Invalid input"
// @Failure 500 {object} utils.ErrorResponse "Internal server error"
// @Security Authentication
// @Security UserID
// @Router /products [post]
func (ctrl *ProductController) CreateProductController(c *gin.Context) <span class="cov0" title="0">{
        var input models.Product

        if err := c.ShouldBind(&amp;input); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("handler: Failed to bind input", zap.Error(err))
                helper.ResponseError(c, "invalid payload", helper.FormatValidationError(err), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">file, err := c.FormFile("image")
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Debug("handler: Failed to get uploaded file", zap.Error(err))
                ctrl.Log.Error("handler: Failed to get uploaded file", zap.Error(err))
                helper.ResponseError(c, "image is required", err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">filePath := "/tmp/" + file.Filename
        if err := c.SaveUploadedFile(file, filePath); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Debug("handler: Failed to save uploaded file", zap.Error(err))
                ctrl.Log.Error("handler: Failed to save uploaded file", zap.Error(err))
                helper.ResponseError(c, "Failed to save file", err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">ctrl.Log.Info("File saved successfully", zap.String("file_path", filePath))

        product, err := ctrl.Service.Product.CreateProduct(&amp;input, filePath)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Debug("handler: Failed to create product", zap.Error(err))
                ctrl.Log.Error("handler: Failed to create product", zap.Error(err))
                helper.ResponseError(c, "Failed to create product", err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">ctrl.Log.Info("handler: Product created successfully", zap.Int("product_id", product.ID))
        helper.ResponseOK(c, product, "create successfully", http.StatusCreated)</span>

}

// GetAllProductsController godoc
// @Summary Get all products with pagination
// @Description Get a paginated list of all products
// @Tags Product
// @Accept json
// @Produce json
// @Param page query int false "Page number" default(1)
// @Param pageSize query int false "Page size" default(10)
// @Success 200 {object} utils.PaginationResponse{Data=[]models.ProductWithCategory} "List of products"
// @Failure 500 {object} utils.ErrorResponse "Failed to fetch products"
// @Security Authentication
// @Security UserID
// @Router /products [get]
func (ctrl *ProductController) GetAllProductsController(c *gin.Context) <span class="cov0" title="0">{
        page := c.DefaultQuery("page", "1")
        pageSize := c.DefaultQuery("pageSize", "10")

        pageInt := helper.StringToInt(page)
        pageSizeInt := helper.StringToInt(pageSize)

        products, totalItems, err := ctrl.Service.Product.GetAllProducts(pageInt, pageSizeInt)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "Product not found" </span><span class="cov0" title="0">{
                        ctrl.Log.Warn("handler: No products found", zap.Int("page", pageInt), zap.Int("pageSize", pageSizeInt))
                        helper.ResponseError(c, "No products found", err.Error(), http.StatusNotFound)
                        return
                }</span>

                <span class="cov0" title="0">ctrl.Log.Debug("handler: Failed to fetch products", zap.Error(err))
                ctrl.Log.Error("handler: Failed to fetch products", zap.Error(err))
                helper.ResponseError(c, "Failed to fetch products", err.Error(), http.StatusInternalServerError)
                return</span>
        }
        <span class="cov0" title="0">totalPages := (totalItems + pageSizeInt - 1) / pageSizeInt

        helper.ResponseOKPagination(c, products, "", pageInt, pageSizeInt, totalItems, totalPages, http.StatusOK)</span>
}

// GetProductByIDController godoc
// @Summary Get product by ID
// @Description Get a specific product by its ID
// @Tags Product
// @Accept json
// @Produce json
// @Param id path int true "Product ID"
// @Success 200 {object} utils.ResponseOK{data=models.Product} "Product details"
// @Failure 404 {object} utils.ErrorResponse "Product not found"
// @Security Authentication
// @Security UserID
// @Router /products/{id} [get]
func (ctrl *ProductController) GetProductByIDController(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        productID := helper.StringToInt(id)

        product, err := ctrl.Service.Product.GetProductByID(productID)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Warn("handler: No products found", zap.Int("id", productID))
                helper.ResponseError(c, "No products found", err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, product, "", http.StatusOK)</span>

}

// UpdateProductController godoc
// @Summary Update a product by ID
// @Description Update an existing product by its ID
// @Tags Product
// @Accept json
// @Produce json
// @Param id path int true "Product ID"
// @Param category_id formData string false "Category ID"
// @Param name formData string false "Product Name"
// @Param code_product formData string false "Code Product"
// @Param description formData string false "Description Product"
// @Param price formData number false "Product Price"
// @Param stock formData int false "Product Stock"
// @Param image formData file false "Product Image"
// @Param published formData boolean false "Is Published"
// @Success 200 {object} utils.ResponseOK{data=models.Product} "Product updated successfully"
// @Failure 400 {object} utils.ErrorResponse "Invalid input"
// @Failure 404 {object} utils.ErrorResponse "Product not found"
// @Failure 500 {object} utils.ErrorResponse "Internal server error"
// @Security Authentication
// @Security UserID
// @Router /products/{id} [put]
func (ctrl *ProductController) UpdateProductController(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        var input models.Product
        if err := c.ShouldBind(&amp;input); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("handler: Failed to bind input", zap.Error(err))
                helper.ResponseError(c, "Invalid payload", helper.FormatValidationError(err), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">file, err := c.FormFile("image")
        filePath := ""
        if err == nil </span><span class="cov0" title="0">{
                filePath = "/tmp/" + file.Filename
                if err := c.SaveUploadedFile(file, filePath); err != nil </span><span class="cov0" title="0">{
                        ctrl.Log.Debug("handler: Failed to save uploaded file", zap.Error(err))
                        ctrl.Log.Error("handler: Failed to save uploaded file", zap.Error(err))
                        helper.ResponseError(c, "Failed to save file", err.Error(), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">ctrl.Log.Info("File saved successfully", zap.String("file_path", filePath))</span>
        }

        <span class="cov0" title="0">product, err := ctrl.Service.Product.UpdateProduct(helper.StringToInt(id), input, filePath)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Debug("handler: Failed to update product", zap.Error(err))
                ctrl.Log.Error("handler: Failed to update product", zap.Error(err))
                helper.ResponseError(c, "Failed to update product", err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">ctrl.Log.Info("handler: Product updated successfully", zap.Int("product_id", product.ID))
        helper.ResponseOK(c, product, "Update successfully", http.StatusOK)</span>
}

// DeleteProductController godoc
// @Summary Delete a product by ID
// @Description Delete a product by its ID
// @Tags Product
// @Accept json
// @Produce json
// @Param id path int true "Product ID"
// @Success 200 {object} utils.ResponseOK "Product deleted successfully"
// @Failure 404 {object} utils.ErrorResponse "Product not found"
// @Failure 500 {object} utils.ErrorResponse "Internal server error"
// @Security Authentication
// @Security UserID
// @Security UserRole
// @Router /products/{id} [delete]
func (ctrl *ProductController) DeleteProductController(c *gin.Context) <span class="cov0" title="0">{
        id := helper.StringToInt(c.Param("id"))

        err := ctrl.Service.Product.DeleteProduct(id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "product not found" </span><span class="cov0" title="0">{
                        ctrl.Log.Warn("handler: No products found", zap.Int("id", id))
                        helper.ResponseError(c, "No products found", err.Error(), http.StatusNotFound)
                }</span> else<span class="cov0" title="0"> {
                        ctrl.Log.Debug("handler: Failed to delete product", zap.Int("id", id), zap.Error(err))
                        ctrl.Log.Error("handler: Failed to delete product", zap.Int("id", id), zap.Error(err))
                        helper.ResponseError(c, "Failed", err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">helper.ResponseOK(c, nil, "Product deleted successfully", http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package promotioncontroller

import (
        "dashboard-ecommerce-team2/helper"
        "dashboard-ecommerce-team2/models"
        "dashboard-ecommerce-team2/service"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type PromotionController struct {
        Service service.Service
        Log     *zap.Logger
}

func NewPromotionController(service service.Service, log *zap.Logger) *PromotionController <span class="cov8" title="1">{
        return &amp;PromotionController{
                Service: service,
                Log:     log,
        }
}</span>

// GetAllPromotionsController godoc
// @Summary Get all promotions
// @Description Retrieve a list of all promotions
// @Tags Promotions
// @Produce json
// @Success 200 {object} models.SuccessResponse{data=[]models.Promotion} "Successfully retrieved promotions"
// @Failure 400 {object} models.ErrorResponse "Bad request"
// @Failure 500 {object} models.ErrorResponse "Internal server error"
// @Router /api/promotions [get]
func (ctrl *PromotionController) GetAllPromotionsController(c *gin.Context) <span class="cov0" title="0">{
        promotion, err := ctrl.Service.Promotion.GetAllPromotions()
        if err != nil </span><span class="cov0" title="0">{
                helper.ResponseError(c, "FAILED", err.Error(), http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, promotion, "Successfully get promotion", http.StatusOK)</span>
}

// GetByIdPromotionsController godoc
// @Summary Get promotion by ID
// @Description Retrieve a specific promotion by its ID
// @Tags Promotions
// @Produce json
// @Param id query int true "Promotion ID"
// @Success 200 {object} models.SuccessResponse{data=[]models.Promotion} "Successfully retrieved promotion"
// @Failure 400 {object} models.ErrorResponse "Invalid promotion ID"
// @Failure 500 {object} models.ErrorResponse "Internal server error"
// @Router /api/promotion [get]
func (ctrl *PromotionController) GetByIdPromotionsController(c *gin.Context) <span class="cov0" title="0">{
        id := c.Request.FormValue("id")
        idInt, err := strconv.Atoi(id)
        if err != nil </span><span class="cov0" title="0">{
                helper.ResponseError(c, "FAILED", "id promotion invalid", http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">promotion, err := ctrl.Service.Promotion.GetByIDPromotion(idInt)
        if err != nil </span><span class="cov0" title="0">{
                helper.ResponseError(c, "FAILED", err.Error(), http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, promotion, "Success get promotion", http.StatusOK)</span>
}

// CreatePromotionController godoc
// @Summary Create a new promotion
// @Description Create a new promotion with detailed information
// @Tags Promotions
// @Accept json
// @Produce json
// @Param promotion body models.SuccessResponse{data=[]models.Promotion} true "Promotion Details"
// @Success 200 {object} models.SuccessResponse{data=[]models.Promotion} "Successfully created promotion"
// @Failure 400 {object} models.ErrorResponse "Invalid input data"
// @Failure 500 {object} models.ErrorResponse "Failed to create promotion"
// @Router /api/promotions [post]
func (ctrl *PromotionController) CreatePromotionController(c *gin.Context) <span class="cov0" title="0">{
        var promotion models.Promotion
        if err := c.ShouldBindJSON(&amp;promotion); err != nil </span><span class="cov0" title="0">{
                helper.ResponseError(c, "INVALID", "invalid data input", http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">if err := ctrl.Service.Promotion.CreatePromotion(&amp;promotion); err != nil </span><span class="cov0" title="0">{
                helper.ResponseError(c, "FAILED", "Failed to create promotion", http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, promotion, "Successfully created promotion", http.StatusOK)</span>
}

// UpdatePromotionController godoc
// @Summary Update promotion published status
// @Description Toggle the published status of a specific promotion
// @Tags Promotions
// @Produce json
// @Param id query int true "Promotion ID"
// @Success 200 {object} models.SuccessResponse{data=[]models.Promotion} "Successfully updated promotion status"
// @Failure 400 {object} models.ErrorResponse "Invalid promotion ID"
// @Failure 500 {object} models.ErrorResponse "Failed to update promotion"
// @Router /api/promotions/status [put]
func (ctrl *PromotionController) UpdatePromotionController(c *gin.Context) <span class="cov0" title="0">{
        id := c.Request.FormValue("id")
        idInt, err := strconv.Atoi(id)
        if err != nil </span><span class="cov0" title="0">{
                helper.ResponseError(c, "FAILED", "promotion id invalid", http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">promotion, err := ctrl.Service.Promotion.GetByIDPromotion(idInt)
        if err != nil </span><span class="cov0" title="0">{
                helper.ResponseError(c, "FAILED", err.Error(), http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        // Toggle published status
        <span class="cov0" title="0">promotion.Published = !promotion.Published
        err = ctrl.Service.Promotion.UpdatePromotion(promotion)
        if err != nil </span><span class="cov0" title="0">{
                helper.ResponseError(c, "FAILED", err.Error(), http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, promotion, "Successfully update published promotion", http.StatusOK)</span>
}

// DeletePromotionController godoc
// @Summary Delete a promotion
// @Description Delete a specific promotion by its ID
// @Tags Promotions
// @Produce json
// @Security ApiKeyAuth
// @Param Authorization header string true "Role"
// @Param id query int true "Promotion ID"
// @Success 200 {object} models.SuccessResponse "Successfully deleted promotion"
// @Failure 400 {object} models.ErrorResponse "Invalid promotion ID"
// @Failure 401 {object} models.ErrorResponse "Unauthorized"
// @Failure 403 {object} models.ErrorResponse "Forbidden - Insufficient privileges"
// @Failure 500 {object} models.ErrorResponse "Failed to delete promotion"
// @Router /api/promotions [delete]
func (ctrl *PromotionController) DeletePromotionController(c *gin.Context) <span class="cov0" title="0">{
        id := c.Request.FormValue("id")
        idInt, err := strconv.Atoi(id)
        if err != nil </span><span class="cov0" title="0">{
                helper.ResponseError(c, "FAILED", "id promotion invalid", http.StatusBadRequest)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">err = ctrl.Service.Promotion.DeletePromotion(idInt)
        if err != nil </span><span class="cov0" title="0">{
                helper.ResponseError(c, "FAILED", err.Error(), http.StatusInternalServerError)
                c.Abort()
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, nil, "Successfully delete promotion", http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package stockcontroller

import (
        "dashboard-ecommerce-team2/helper"
        "dashboard-ecommerce-team2/models"
        "dashboard-ecommerce-team2/service"
        "net/http"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type StockController struct {
        Service service.Service
        Log     *zap.Logger
}

func NewStockController(service service.Service, log *zap.Logger) *StockController <span class="cov8" title="1">{
        return &amp;StockController{
                Service: service,
                Log:     log,
        }
}</span>

// UpdateProductStockController godoc
// @Summary      Update product stock
// @Description  Update the stock of a product (increase or decrease).
// @Tags         Stock
// @Accept       json
// @Produce      json
// @Param        stock_request  body      models.StockRequest  true  "Stock update request"
// @Success      200            {object}  utils.ResponseOK "Update success"
// @Failure      400            {object}  utils.ErrorResponse "Invalid input"
// @Failure      500            {object}  utils.ErrorResponse "Internal server error"
// @Security Authentication
// @Security UserID
// @Router       /stock [put]
func (ctrl *StockController) UpdateProductStockController(c *gin.Context) <span class="cov0" title="0">{
        var req models.StockRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Warn("invalid input", zap.Error(err))
                helper.ResponseError(c, "Invalid input", helper.FormatValidationError(err), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Type != "in" &amp;&amp; req.Type != "out" </span><span class="cov0" title="0">{
                ctrl.Log.Warn("invalid stock type", zap.String("type", req.Type))
                helper.ResponseError(c, "Invalid stock type", "Type must be 'in' or 'out'", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := ctrl.Service.Stock.UpdateProductStock(&amp;req); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("failed to update stock", zap.Error(err))
                helper.ResponseError(c, "Failed to update stock", err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, nil, "Stock updated successfully", http.StatusOK)</span>
}

// GetProductStockDetailController godoc
// @Summary      Get product stock details
// @Description  Retrieve the stock details of a specific product by stock history ID.
// @Tags         Stock
// @Accept       json
// @Produce      json
// @Param        id   path      int  true  "Stock history ID"
// @Success      200  {object}  utils.ResponseOK{data=utils.StockResponse} "Detail Stock history"
// @Failure      404  {object}  utils.ErrorResponse "Stock History not found"
// @Security Authentication
// @Security UserID
// @Router       /stock/{id} [get]
func (ctrl *StockController) GetProductStockDetailController(c *gin.Context) <span class="cov0" title="0">{
        id := helper.StringToInt(c.Param("id"))
        stockHistory, err := ctrl.Service.Stock.GetProductStockDetail(id)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Warn("handler: No history found", zap.Int("id", id))
                helper.ResponseError(c, "No history found", err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">helper.ResponseOK(c, stockHistory, "", http.StatusOK)</span>
}

// DeleteProductStockController godoc
// @Summary      Delete stock history
// @Description  Delete a specific stock history record by its ID.
// @Tags         Stock
// @Accept       json
// @Produce      json
// @Param        id   path      int  true  "Stock history ID"
// @Success      200  {object}  utils.ResponseOK "Delete Success"
// @Failure      404  {object}  utils.ErrorResponse "Stock history not found"
// @Failure      500  {object}  utils.ErrorResponse "Internal server error"
// @Security Authentication
// @Security UserID
// @Security UserRole
// @Router       /stock/{id} [delete]
func (ctrl *StockController) DeleteProductStockController(c *gin.Context) <span class="cov0" title="0">{
        id := helper.StringToInt(c.Param("id"))

        err := ctrl.Service.Stock.DeleteProductStock(id)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "history not found" </span><span class="cov0" title="0">{
                        ctrl.Log.Warn("handler: No history found", zap.Int("id", id))
                        helper.ResponseError(c, "No history found", err.Error(), http.StatusNotFound)
                }</span> else<span class="cov0" title="0"> {
                        ctrl.Log.Debug("handler: Failed to delete history", zap.Int("id", id), zap.Error(err))
                        ctrl.Log.Error("handler: Failed to delete history", zap.Int("id", id), zap.Error(err))
                        helper.ResponseError(c, "Failed", err.Error(), http.StatusInternalServerError)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">helper.ResponseOK(c, nil, "history deleted successfully", http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package usercontroller

import (
        "dashboard-ecommerce-team2/config"
        "dashboard-ecommerce-team2/database"
        "dashboard-ecommerce-team2/helper"
        "dashboard-ecommerce-team2/models"
        "dashboard-ecommerce-team2/service"
        utils "dashboard-ecommerce-team2/util"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type UserController struct {
        Service service.Service
        Log     *zap.Logger
        Cacher  database.Cacher
        Config  config.Configuration
}

func NewUserController(service service.Service, log *zap.Logger, cacher database.Cacher, config config.Configuration) *UserController <span class="cov0" title="0">{
        return &amp;UserController{
                Service: service,
                Log:     log,
                Cacher:  cacher,
                Config:  config,
        }
}</span>

// CreateUserController godoc
// @Summary      Create a new user
// @Description  Register a new user with a provided request body
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        registerRequest  body     models.RegisterRequest  true  "User Registration Request Body"
// @Success      201             {object} helper.HTTPResponse   "User created successfully"
// @Failure      400             {object} helper.HTTPResponse   "Invalid request body"
// @Failure      500             {object} helper.HTTPResponse   "Failed to create user"
// @Router       /auth/register [post]
func (ctrl *UserController) CreateUserController(c *gin.Context) <span class="cov8" title="1">{
        var registerReq models.RegisterRequest
        if err := c.ShouldBindJSON(&amp;registerReq); err != nil </span><span class="cov8" title="1">{
                ctrl.Log.Error("Invalid request body", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">err := ctrl.Service.User.CreateUser(registerReq)
        if err != nil </span><span class="cov8" title="1">{
                ctrl.Log.Error("Failed to create user", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Failed to create user", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">helper.ResponseOK(c, nil, "User created successfully", http.StatusCreated)</span>
}

// LoginController godoc
// @Summary      User Login
// @Description  Authenticate a user and return a token
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        loginRequest  body     models.LoginRequest  true  "Login Request Body"
// @Success      200           {object} helper.HTTPResponse   "User logged in successfully"
// @Failure      400           {object} helper.HTTPResponse   "Invalid request body"
// @Failure      401           {object} helper.HTTPResponse   "Failed to login user"
// @Router       /auth/login [post]
func (ctrl *UserController) LoginController(c *gin.Context) <span class="cov0" title="0">{
        var loginReq models.LoginRequest
        if err := c.ShouldBindJSON(&amp;loginReq); err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Invalid request body", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Invalid request body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">user, err := ctrl.Service.User.Login(loginReq)
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Log.Error("Failed to login user", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Failed to login user", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">userIDStr := helper.IntToString(user.ID)
        key := fmt.Sprintf("UserID-%s", userIDStr)
        token := helper.GenerateToken(userIDStr, ctrl.Config.SecretKey)
        loginResponse := utils.LoginResponse{
                ID:    key,
                Role:  user.Role,
                Token: token,
        }

        ctrl.Cacher.SaveToken(key, token)
        helper.ResponseOK(c, loginResponse, "User logged in successfully", http.StatusOK)</span>
}

// CheckEmailUserController godoc
// @Summary      Check if email is already registered
// @Description  Verify if a user with the given email already exists in the system
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        email  body     models.CheckEmailRequest  true  "Email to check"
// @Success      200    {object} helper.HTTPResponse     "Email check result"
// @Failure      400    {object} helper.HTTPResponse     "Invalid request body"
// @Failure      500    {object} helper.HTTPResponse     "Failed to check user email"
// @Router       /auth/check-email [post]
func (ctrl *UserController) CheckEmailUserController(c *gin.Context) <span class="cov8" title="1">{
        request := models.CheckEmailRequest{}
        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov8" title="1">{
                ctrl.Log.Error("Invalid request body", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">existedUser, err := ctrl.Service.User.CheckUserEmail(request.Email)
        if err != nil </span><span class="cov8" title="1">{
                ctrl.Log.Error("Failed to check user email", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Failed to check user email", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">helper.ResponseOK(c, existedUser, "User email exists", http.StatusOK)</span>
}

// ResetUserPasswordController godoc
// @Summary      Reset user password
// @Description  Reset the password for a user using a provided request body
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        resetRequest  body     models.LoginRequest  true  "User password reset request body"
// @Success      200           {object} helper.HTTPResponse   "User password reset successfully"
// @Failure      400           {object} helper.HTTPResponse   "Invalid request body"
// @Failure      500           {object} helper.HTTPResponse   "Failed to reset user password"
// @Router       /auth/reset-password [PATCH]
func (ctrl *UserController) ResetUserPasswordController(c *gin.Context) <span class="cov8" title="1">{
        var resetReq models.LoginRequest
        if err := c.ShouldBindJSON(&amp;resetReq); err != nil </span><span class="cov8" title="1">{
                ctrl.Log.Error("Invalid request body", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">err := ctrl.Service.User.ResetUserPassword(resetReq)
        if err != nil </span><span class="cov8" title="1">{
                ctrl.Log.Error("Failed to reset user password", zap.Error(err))
                helper.ResponseError(c, err.Error(), "Failed to reset user password", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov8" title="1">helper.ResponseOK(c, nil, "User password reset successfully", http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package database

import (
        "dashboard-ecommerce-team2/config"
        "fmt"
        "log"
        "os"
        "time"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

func InitDB(config config.Configuration) (*gorm.DB, error) <span class="cov8" title="1">{
        // Format connection string
        connStr := fmt.Sprintf("user=%s password=%s dbname=%s sslmode=disable host=%s TimeZone=%s",
                config.DBConfig.DBUsername, config.DBConfig.DBPassword, config.DBConfig.DBName, config.DBConfig.DBHost, config.DBConfig.DBTimeZone)

        // Setup logger for GORM
        newLogger := logger.New(
                log.New(os.Stdout, "\r\n", log.LstdFlags), // io writer
                logger.Config{
                        SlowThreshold:             time.Second, // Slow SQL threshold
                        LogLevel:                  logger.Info, // Log level
                        IgnoreRecordNotFoundError: false,       // Ignore ErrRecordNotFound error for logger
                        Colorful:                  true,        // Disable color
                },
        )

        // Open a connection to the PostgreSQL databas
        db, err := gorm.Open(postgres.Open(connStr), &amp;gorm.Config{
                Logger: newLogger,
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        // Convert to *sql.DB for setting connection options
        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set connection pool options
        <span class="cov0" title="0">sqlDB.SetConnMaxIdleTime(time.Duration(config.DBConfig.DBMaxIdleTime) * time.Minute)
        sqlDB.SetConnMaxLifetime(time.Duration(config.DBConfig.DBMaxLifeTime) * time.Hour)
        sqlDB.SetMaxIdleConns(config.DBConfig.DBMaxIdleConns)
        sqlDB.SetMaxOpenConns(config.DBConfig.DBMaxOpenConns)

        err = sqlDB.Ping()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR: Database connection failed: %v\n", err)
                return nil, fmt.Errorf("ERROR: unable to connect to the database: %v", err)
        }</span>
        <span class="cov0" title="0">log.Println("INFO: Database connected successfully!")

        if !config.MigrateUsed </span><span class="cov0" title="0">{
                // Migration tabel form struct
                log.Println("Starting migration...")
                err = Migrate(db)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("ERROR: unable to migrate database: %v", err)
                }</span>
                <span class="cov0" title="0">log.Println("Migration completed successfully.")

                // running seeder
                log.Println("Starting seeding...")
                err := SeedAll(db)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("ERROR: failed seedingAll, message: %s", err.Error())
                }</span>
        }

        <span class="cov0" title="0">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package database

import (
        "dashboard-ecommerce-team2/models"
        "fmt"
        "log"

        "gorm.io/gorm"
)

func Migrate(db *gorm.DB) error <span class="cov0" title="0">{
        if err := db.Exec(`CREATE TABLE IF NOT EXISTS migrations (
                id SERIAL PRIMARY KEY,
                name VARCHAR(255) UNIQUE,
                applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )`).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrations table: %w", err)
        }</span>

        // Define migrations
        <span class="cov0" title="0">allModel := []struct {
                name  string
                model interface{}
        }{
                {"user", models.User{}},
                {"category", models.Category{}},
                {"product", models.Product{}},
                {"stock", models.Stock{}},
                {"banner", models.Banner{}},
                {"order", models.Order{}},
                {"order_item", models.OrderItem{}},
                {"promotion", models.Promotion{}},
        }

        for _, migration := range allModel </span><span class="cov0" title="0">{
                var count int64
                err := db.Raw("SELECT COUNT(1) FROM migrations WHERE name = ?", migration.name).Scan(&amp;count).Error
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check migration status for %s: %w", migration.name, err)
                }</span>

                <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                        log.Printf("Migration '%s' already applied, skipping.", migration.name)
                        continue</span>
                }

                // Run migration
                <span class="cov0" title="0">if err := db.AutoMigrate(migration.model); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to migrate model %T: %w", migration.model, err)
                }</span>

                // Record migration as applied
                <span class="cov0" title="0">if err := db.Exec("INSERT INTO migrations (name) VALUES (?)", migration.name).Error; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to record migration %s: %w", migration.name, err)
                }</span>

                <span class="cov0" title="0">log.Printf("Migration '%s' applied successfully.", migration.name)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package database

import (
        "context"
        "dashboard-ecommerce-team2/config"
        "fmt"
        "log"
        "time"

        "github.com/go-redis/redis/v8"
)

type Cacher struct {
        rdb      *redis.Client
        expiracy time.Duration
        prefix   string
}

func newRedisClient(url, password string, dbIndex int) *redis.Client <span class="cov8" title="1">{
        return redis.NewClient(&amp;redis.Options{
                Addr:     url,
                Password: password,
                DB:       dbIndex,
        })
}</span>
func NewCacher(cfg config.Configuration, expiracy int) Cacher <span class="cov8" title="1">{
        client := newRedisClient(cfg.RedisConfig.Url, cfg.RedisConfig.Password, 0)

        // Test Redis connection and log the result
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        _, err := client.Ping(ctx).Result()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to connect to Redis: %v", err)
        }</span> else<span class="cov8" title="1"> {
                log.Println("Redis connected successfully!")
        }</span>

        <span class="cov8" title="1">cache := Cacher{
                rdb:      client,
                expiracy: time.Duration(expiracy) * time.Second,
                prefix:   cfg.RedisConfig.Prefix,
        }

        return cache</span>
}

func (c *Cacher) Push(name string, value []byte) error <span class="cov0" title="0">{
        return c.rdb.RPush(context.Background(), c.prefix+"_"+name, value).Err()
}</span>

func (c *Cacher) Pop(name string) (string, error) <span class="cov0" title="0">{
        return c.rdb.LPop(context.Background(), c.prefix+"_"+name).Result()
}</span>

func (c *Cacher) GetLength(name string) int64 <span class="cov0" title="0">{
        return c.rdb.LLen(context.Background(), c.prefix+"_"+name).Val()
}</span>

func (c *Cacher) Set(name string, value string) error <span class="cov0" title="0">{
        return c.rdb.Set(context.Background(), c.prefix+"_"+name, value, c.expiracy).Err()
}</span>

func (c *Cacher) SaveToken(name string, value string) error <span class="cov0" title="0">{
        log.Printf("Saving token for %s:%s", name, value)
        return c.rdb.Set(context.Background(), c.prefix+"_"+name, value, 20*time.Hour).Err()
}</span>

func (c *Cacher) Get(name string) (string, error) <span class="cov0" title="0">{
        result, err := c.rdb.Get(context.Background(), c.prefix+"_"+name).Result()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("error getting token from Redis: ", err)
        }</span>
        <span class="cov0" title="0">return result, err</span>
}

func (c *Cacher) Delete(name string) error <span class="cov0" title="0">{
        return c.rdb.Del(context.Background(), c.prefix+"_"+name).Err()
}</span>

func (c *Cacher) DeleteByKey(key string) error <span class="cov0" title="0">{
        return c.rdb.Del(context.Background(), key).Err()
}</span>

func (c *Cacher) PrintKeys() <span class="cov0" title="0">{
        var cursor uint64
        for </span><span class="cov0" title="0">{
                var keys []string
                var err error
                keys, cursor, err = c.rdb.Scan(context.Background(), cursor, "", 0).Result()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov0" title="0">for _, key := range keys </span><span class="cov0" title="0">{
                        fmt.Println("key", key)
                }</span>

                <span class="cov0" title="0">if cursor == 0 </span><span class="cov0" title="0">{ // no more keys
                        break</span>
                }
        }
}

func (c *Cacher) GetKeys() []string <span class="cov0" title="0">{
        var cursor uint64
        var result []string
        for </span><span class="cov0" title="0">{
                var keys []string
                var err error
                keys, cursor, err = c.rdb.Scan(context.Background(), cursor, "", 0).Result()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov0" title="0">result = append(result, keys...)

                if cursor == 0 </span><span class="cov0" title="0">{ // no more keys
                        break</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

func (c *Cacher) GetKeysByPattern(pattern string) []string <span class="cov0" title="0">{
        var cursor uint64
        var result []string
        for </span><span class="cov0" title="0">{
                var keys []string
                var err error
                keys, cursor, err = c.rdb.Scan(context.Background(), cursor, pattern, 0).Result()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }

                <span class="cov0" title="0">result = append(result, keys...)

                if cursor == 0 </span><span class="cov0" title="0">{ // no more keys
                        break</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

// Pub and Sub
func (c *Cacher) Publish(channelName string, message string) error <span class="cov0" title="0">{
        return c.rdb.Publish(context.Background(), channelName, message).Err()
}</span>

func (c *Cacher) Subcribe(channelName string) (*redis.Message, error) <span class="cov0" title="0">{
        subscriber := c.rdb.Subscribe(context.Background(), channelName)
        message, err := subscriber.ReceiveMessage(context.Background())
        return message, err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package database

import (
        "dashboard-ecommerce-team2/models"
        "fmt"
        "log"
        "reflect"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

func SeedAll(db *gorm.DB) error <span class="cov0" title="0">{
        return db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                seeds := dataSeeds()
                for _, seed := range seeds </span><span class="cov0" title="0">{
                        var count int64
                        name := reflect.TypeOf(seed).String()

                        if err := tx.Model(seed).Count(&amp;count).Error; err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Error checking data for table %s: %v", name, err)
                                return err
                        }</span>

                        <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                                log.Printf("Seeding skipped for table %s, data already exists.", name)
                                continue</span>
                        }

                        <span class="cov0" title="0">err := tx.Clauses(clause.OnConflict{DoNothing: true}).Create(seed).Error
                        if err != nil </span><span class="cov0" title="0">{
                                errorMessage := err.Error()
                                log.Printf("%s seeder failed with error: %s", name, errorMessage)
                                continue</span>
                        }

                        <span class="cov0" title="0">resetSequence(tx, seed)</span>
                }

                <span class="cov0" title="0">log.Println("Seeding completed successfully.")
                return nil</span>
        })
}

// resetSequence resets the auto-increment sequence in case of conflict or error
func resetSequence(tx *gorm.DB, seed interface{}) <span class="cov0" title="0">{
        if tx.Dialector.Name() == "postgres" </span><span class="cov0" title="0">{
                tableName := getTableName(seed)
                if tableName != "" </span><span class="cov0" title="0">{
                        // Reset the sequence for PostgreSQL
                        query := fmt.Sprintf(`
                                SELECT setval(pg_get_serial_sequence('%s', 'id'), 
                                COALESCE((SELECT MAX(id) FROM %s), 1))`, tableName, tableName)
                        if err := tx.Exec(query).Error; err != nil </span><span class="cov0" title="0">{
                                log.Printf("[WARNING] Failed to reset sequence for table %s: %s", tableName, err)
                        }</span>
                }
        }
}

// getTableName returns the table name from the seed's struct
func getTableName(seed interface{}) string <span class="cov0" title="0">{
        seedType := reflect.TypeOf(seed)
        if seedType.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                seedType = seedType.Elem()
        }</span>
        <span class="cov0" title="0">if seedType.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                return seedType.Name()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func dataSeeds() []interface{} <span class="cov0" title="0">{
        return []interface{}{
                models.UserSeed(),
                models.CategorySeed(),
                models.ProductSeed(),
                models.StockSeed(),
                models.BannerSeed(),
                models.OrderSeed(),
                models.OrderItemSeed(),
                models.PromotionSeed(),
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Code generated by swaggo/swag. DO NOT EDIT.

package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://example.com/terms/",
        "contact": {
            "name": "API Support",
            "url": "http://example.com/support",
            "email": "support@example.com"
        },
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/banner": {
            "get": {
                "description": "Retrieve a specific banner by its ID",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Banner"
                ],
                "summary": "Get banner by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Banner ID",
                        "name": "id",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully retrieved banner",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/models.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.Banner"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid banner ID",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to retrieve banner",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Toggle the published status of a banner",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Banner"
                ],
                "summary": "Update banner published status",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Banner ID",
                        "name": "id",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully updated published banner",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/models.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.Banner"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid banner ID",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to update banner",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Remove a banner by its ID",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Banner"
                ],
                "summary": "Delete a banner",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Role",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Banner ID",
                        "name": "id",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully deleted banner",
                        "schema": {
                            "$ref": "#/definitions/models.SuccessResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid banner ID",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to delete banner",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/create-banner": {
            "post": {
                "description": "Create a new banner with image upload",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Banner"
                ],
                "summary": "Create a new banner",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Banner Title",
                        "name": "title",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Banner Description",
                        "name": "description",
                        "in": "formData"
                    },
                    {
                        "type": "file",
                        "description": "Banner Image",
                        "name": "image_path",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully created banner",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/models.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.Banner"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid data input",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to upload image or create banner",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/promotion": {
            "get": {
                "description": "Retrieve a specific promotion by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Promotions"
                ],
                "summary": "Get promotion by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Promotion ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully retrieved promotion",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/models.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/models.Promotion"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid promotion ID",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/promotions": {
            "get": {
                "description": "Retrieve a list of all promotions",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Promotions"
                ],
                "summary": "Get all promotions",
                "responses": {
                    "200": {
                        "description": "Successfully retrieved promotions",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/models.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/models.Promotion"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Bad request",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Create a new promotion with detailed information",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Promotions"
                ],
                "summary": "Create a new promotion",
                "parameters": [
                    {
                        "description": "Promotion Details",
                        "name": "promotion",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/models.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/models.Promotion"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully created promotion",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/models.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/models.Promotion"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid input data",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to create promotion",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Delete a specific promotion by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Promotions"
                ],
                "summary": "Delete a promotion",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Role",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Promotion ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully deleted promotion",
                        "schema": {
                            "$ref": "#/definitions/models.SuccessResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid promotion ID",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden - Insufficient privileges",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to delete promotion",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/promotions/status": {
            "put": {
                "description": "Toggle the published status of a specific promotion",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Promotions"
                ],
                "summary": "Update promotion published status",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Promotion ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully updated promotion status",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/models.SuccessResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/models.Promotion"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid promotion ID",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to update promotion",
                        "schema": {
                            "$ref": "#/definitions/models.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/check-email": {
            "post": {
                "description": "Verify if a user with the given email already exists in the system",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Check if email is already registered",
                "parameters": [
                    {
                        "description": "Email to check",
                        "name": "email",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CheckEmailRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Email check result",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request body",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to check user email",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            }
        },
        "/auth/login": {
            "post": {
                "description": "Authenticate a user and return a token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "User Login",
                "parameters": [
                    {
                        "description": "Login Request Body",
                        "name": "loginRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "User logged in successfully",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request body",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "401": {
                        "description": "Failed to login user",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            }
        },
        "/auth/register": {
            "post": {
                "description": "Register a new user with a provided request body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Create a new user",
                "parameters": [
                    {
                        "description": "User Registration Request Body",
                        "name": "registerRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.RegisterRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User created successfully",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request body",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to create user",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            }
        },
        "/auth/reset-password": {
            "patch": {
                "description": "Reset the password for a user using a provided request body",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "Reset user password",
                "parameters": [
                    {
                        "description": "User password reset request body",
                        "name": "resetRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.LoginRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "User password reset successfully",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request body",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to reset user password",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            }
        },
        "/category/:id": {
            "get": {
                "description": "Retrieve a category by its ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Categories"
                ],
                "summary": "Get category by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Category ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Category data",
                        "schema": {
                            "$ref": "#/definitions/models.Category"
                        }
                    },
                    "400": {
                        "description": "Invalid category ID",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "404": {
                        "description": "Category not found",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Update the details of an existing category by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "categories"
                ],
                "summary": "Update a category",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Category ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Updated category details",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.Category"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully updated the category",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid category ID or input",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "404": {
                        "description": "Category not found",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to update category",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete a category by its ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Categories"
                ],
                "summary": "Delete category by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Category ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully deleted the category",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid category ID",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to delete category",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            }
        },
        "/category/create": {
            "post": {
                "description": "Create a new category with a name",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Categories"
                ],
                "summary": "Create a new category",
                "parameters": [
                    {
                        "description": "Category name",
                        "name": "category",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.Category"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Successfully created the category",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to create category",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            }
        },
        "/category/list": {
            "get": {
                "description": "Retrieve all categories with pagination",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Categories"
                ],
                "summary": "Get all categories",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 1,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 10,
                        "description": "Number of items per page",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of categories",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            }
        },
        "/dashboard/best-item-list": {
            "get": {
                "description": "Retrieve a list of the best-selling products",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Dashboard"
                ],
                "summary": "Get best product list",
                "responses": {
                    "200": {
                        "description": "best product list successfully retrieved",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "500": {
                        "description": "Error getting best product list",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            }
        },
        "/dashboard/current-month-earning": {
            "get": {
                "description": "Retrieve the earnings for the current month",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Dashboard"
                ],
                "summary": "Get current month earnings",
                "responses": {
                    "200": {
                        "description": "current month earnings successfully retrieved",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "500": {
                        "description": "Error getting earnings",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            }
        },
        "/dashboard/revenue-chart": {
            "get": {
                "description": "Generate a revenue chart for the dashboard",
                "produces": [
                    "text/html"
                ],
                "tags": [
                    "Dashboard"
                ],
                "summary": "Get revenue chart",
                "responses": {
                    "200": {
                        "description": "\u003c!DOCTYPE html\u003e\u003chtml\u003e\u003chead\u003e\u003cmeta charset='utf-8'\u003e\u003ctitle\u003eAwesome go-echarts\u003c/title\u003e\u003cscript src='https://go-echarts.github.io/go-echarts-assets/assets/echarts.min.js'\u003e\u003c/script\u003e\u003c/head\u003e\u003cbody\u003e\u003cdiv class='container'\u003e\u003cdiv class='item' id='PvBdsRyYJxot' style='width:900px;height:500px;'\u003e\u003c/div\u003e\u003c/div\u003e\u003cscript type='text/javascript'\u003e\\\"use strict\\\";let goecharts_PvBdsRyYJxot = echarts.init(document.getElementById('PvBdsRyYJxot'), 'white', { renderer: 'canvas' });let option_PvBdsRyYJxot = {\\\"color\\\":[\\\"#5470c6\\\",\\\"#91cc75\\\",\\\"#fac858\\\",\\\"#ee6666\\\",\\\"#73c0de\\\",\\\"#3ba272\\\",\\\"#fc8452\\\",\\\"#9a60b4\\\",\\\"#ea7ccc\\\"],\\\"legend\\\":{},\\\"series\\\":[{\\\"name\\\":\\\"Revenue\\\",\\\"type\\\":\\\"line\\\",\\\"smooth\\\":true,\\\"data\\\":[{\\\"value\\\":150.75},{\\\"value\\\":300},{\\\"value\\\":500.5},{\\\"value\\\":175.25},{\\\"value\\\":250},{\\\"value\\\":100.75},{\\\"value\\\":400.5},{\\\"value\\\":300.25},{\\\"value\\\":275},{\\\"value\\\":125.5},{\\\"value\\\":500},{\\\"value\\\":350}]}],\\\"title\\\":{\\\"text\\\":\\\"Monthly Revenue\\\"},\\\"toolbox\\\":{},\\\"tooltip\\\":{},\\\"xAxis\\\":[{\\\"name\\\":\\\"Month\\\",\\\"data\\\":[\\\"January  \\\",\\\"February \\\",\\\"March    \\\",\\\"April    \\\",\\\"May      \\\",\\\"June     \\\",\\\"July     \\\",\\\"August   \\\",\\\"September\\\",\\\"October  \\\",\\\"November \\\",\\\"December \\\"]}],\\\"yAxis\\\":[{\\\"name\\\":\\\"Revenue\\\"}]}goecharts_PvBdsRyYJxot.setOption(option_PvBdsRyYJxot);\u003c/script\u003e\u003cstyle\u003e.container {margin-top:30px; display: flex;justify-content: center;align-items: center;}.item {margin: auto;}\u003c/style\u003e\u003c/body\u003e\u003c/html\u003e",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Error generating revenue chart",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            }
        },
        "/dashboard/summary": {
            "get": {
                "description": "Retrieve a summary of the dashboard",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Dashboard"
                ],
                "summary": "Get dashboard summary",
                "responses": {
                    "200": {
                        "description": "dashboard summary successfully retrieved",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "500": {
                        "description": "Error getting summary",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            }
        },
        "/orders/": {
            "get": {
                "description": "Get a paginated list of orders",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "orders"
                ],
                "summary": "Get all orders with pagination",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 1,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 10,
                        "description": "Number of items per page",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            }
        },
        "/orders/detail/{id}": {
            "get": {
                "description": "Get the details of an order by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "orders"
                ],
                "summary": "Get order detail by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Order ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid order ID",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to fetch order details",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            }
        },
        "/orders/{id}": {
            "get": {
                "description": "Get a single order by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "orders"
                ],
                "summary": "Get order by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Order ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.Order"
                        }
                    }
                }
            },
            "put": {
                "description": "Update the status of an order by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Orders"
                ],
                "summary": "Update order status",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Order ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "example": "\"shipped\"",
                        "description": "Order Status",
                        "name": "status",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "string"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully updated the order status",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid order ID",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to update order status",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Delete an order by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "orders"
                ],
                "summary": "Delete order by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Order ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successfully deleted the order",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid order ID",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to delete the order",
                        "schema": {
                            "$ref": "#/definitions/helper.HTTPResponse"
                        }
                    }
                }
            }
        },
        "/products": {
            "get": {
                "security": [
                    {
                        "Authentication": []
                    },
                    {
                        "UserID": []
                    }
                ],
                "description": "Get a paginated list of all products",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "Get all products with pagination",
                "parameters": [
                    {
                        "type": "integer",
                        "default": 1,
                        "description": "Page number",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 10,
                        "description": "Page size",
                        "name": "pageSize",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of products",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/utils.PaginationResponse"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "Data": {
                                            "type": "array",
                                            "items": {
                                                "$ref": "#/definitions/models.ProductWithCategory"
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "500": {
                        "description": "Failed to fetch products",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "Authentication": []
                    },
                    {
                        "UserID": []
                    }
                ],
                "description": "Create a new product with an image",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "Creates a new product",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Category ID",
                        "name": "category_id",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Product Name",
                        "name": "name",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Code Product",
                        "name": "code_product",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Description Product",
                        "name": "description",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "number",
                        "description": "Product Price",
                        "name": "price",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Product Stock",
                        "name": "stock",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "file",
                        "description": "Product Image",
                        "name": "image",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Product created successfully",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/utils.ResponseOK"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.Product"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/products/{id}": {
            "get": {
                "security": [
                    {
                        "Authentication": []
                    },
                    {
                        "UserID": []
                    }
                ],
                "description": "Get a specific product by its ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "Get product by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Product ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Product details",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/utils.ResponseOK"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.Product"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Product not found",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "Authentication": []
                    },
                    {
                        "UserID": []
                    }
                ],
                "description": "Update an existing product by its ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "Update a product by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Product ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Category ID",
                        "name": "category_id",
                        "in": "formData"
                    },
                    {
                        "type": "string",
                        "description": "Product Name",
                        "name": "name",
                        "in": "formData"
                    },
                    {
                        "type": "string",
                        "description": "Code Product",
                        "name": "code_product",
                        "in": "formData"
                    },
                    {
                        "type": "string",
                        "description": "Description Product",
                        "name": "description",
                        "in": "formData"
                    },
                    {
                        "type": "number",
                        "description": "Product Price",
                        "name": "price",
                        "in": "formData"
                    },
                    {
                        "type": "integer",
                        "description": "Product Stock",
                        "name": "stock",
                        "in": "formData"
                    },
                    {
                        "type": "file",
                        "description": "Product Image",
                        "name": "image",
                        "in": "formData"
                    },
                    {
                        "type": "boolean",
                        "description": "Is Published",
                        "name": "published",
                        "in": "formData"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Product updated successfully",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/utils.ResponseOK"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/models.Product"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Product not found",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "Authentication": []
                    },
                    {
                        "UserID": []
                    },
                    {
                        "UserRole": []
                    }
                ],
                "description": "Delete a product by its ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "Delete a product by ID",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Product ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Product deleted successfully",
                        "schema": {
                            "$ref": "#/definitions/utils.ResponseOK"
                        }
                    },
                    "404": {
                        "description": "Product not found",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/stock": {
            "put": {
                "security": [
                    {
                        "Authentication": []
                    },
                    {
                        "UserID": []
                    }
                ],
                "description": "Update the stock of a product (increase or decrease).",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Stock"
                ],
                "summary": "Update product stock",
                "parameters": [
                    {
                        "description": "Stock update request",
                        "name": "stock_request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.StockRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Update success",
                        "schema": {
                            "$ref": "#/definitions/utils.ResponseOK"
                        }
                    },
                    "400": {
                        "description": "Invalid input",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/stock/{id}": {
            "get": {
                "security": [
                    {
                        "Authentication": []
                    },
                    {
                        "UserID": []
                    }
                ],
                "description": "Retrieve the stock details of a specific product by stock history ID.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Stock"
                ],
                "summary": "Get product stock details",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Stock history ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Detail Stock history",
                        "schema": {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/utils.ResponseOK"
                                },
                                {
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "$ref": "#/definitions/utils.StockResponse"
                                        }
                                    }
                                }
                            ]
                        }
                    },
                    "404": {
                        "description": "Stock History not found",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "Authentication": []
                    },
                    {
                        "UserID": []
                    },
                    {
                        "UserRole": []
                    }
                ],
                "description": "Delete a specific stock history record by its ID.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Stock"
                ],
                "summary": "Delete stock history",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Stock history ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Delete Success",
                        "schema": {
                            "$ref": "#/definitions/utils.ResponseOK"
                        }
                    },
                    "404": {
                        "description": "Stock history not found",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/utils.ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "helper.HTTPResponse": {
            "type": "object",
            "properties": {
                "data": {},
                "error_msg": {
                    "type": "string"
                },
                "limit": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "page": {
                    "type": "integer"
                },
                "total_items": {
                    "type": "integer"
                },
                "total_pages": {
                    "type": "integer"
                }
            }
        },
        "models.Banner": {
            "type": "object",
            "properties": {
                "end_date": {
                    "type": "string",
                    "example": "2024-03-31"
                },
                "image": {
                    "type": "string",
                    "example": "/images/banner1.png"
                },
                "path_page": {
                    "type": "string",
                    "example": "/spring-sale"
                },
                "published": {
                    "type": "boolean",
                    "example": true
                },
                "release_date": {
                    "type": "string",
                    "example": "2024-03-01"
                },
                "title": {
                    "type": "string",
                    "example": "Spring Sale 2024"
                },
                "type": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "example": [
                        "[\"seasonal\"",
                        " \"promo\"]"
                    ]
                }
            }
        },
        "models.Category": {
            "type": "object"
        },
        "models.CheckEmailRequest": {
            "type": "object",
            "required": [
                "email"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "example": "johndoe@example"
                }
            }
        },
        "models.ErrorResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "models.LoginRequest": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "example": "johndoe@example.com"
                },
                "password": {
                    "type": "string",
                    "minLength": 8,
                    "example": "password123"
                }
            }
        },
        "models.Order": {
            "type": "object",
            "required": [
                "payment_method",
                "status",
                "total_amount",
                "user_id"
            ],
            "properties": {
                "payment_method": {
                    "type": "string",
                    "example": "credit_card"
                },
                "shipping_address": {
                    "type": "string",
                    "example": "123 Main St"
                },
                "status": {
                    "type": "string",
                    "example": "pending"
                },
                "total_amount": {
                    "type": "number",
                    "example": 150.75
                },
                "user_id": {
                    "type": "integer",
                    "example": 1
                }
            }
        },
        "models.Product": {
            "type": "object",
            "required": [
                "category_id",
                "code_product",
                "name",
                "price",
                "stock"
            ],
            "properties": {
                "category_id": {
                    "type": "integer",
                    "example": 1
                },
                "code_product": {
                    "type": "string",
                    "example": "SPH-001"
                },
                "description": {
                    "type": "string",
                    "example": "Latest smartphone with advanced features"
                },
                "name": {
                    "type": "string",
                    "minLength": 3,
                    "example": "Smartphone"
                },
                "price": {
                    "type": "number",
                    "example": 699.99
                },
                "published": {
                    "type": "boolean",
                    "example": true
                },
                "stock": {
                    "type": "integer",
                    "example": 50
                }
            }
        },
        "models.ProductWithCategory": {
            "type": "object",
            "properties": {
                "category_name": {
                    "type": "string"
                },
                "code_product": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "images": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                },
                "price": {
                    "type": "number"
                },
                "published": {
                    "type": "boolean"
                },
                "stock": {
                    "type": "integer"
                }
            }
        },
        "models.Promotion": {
            "type": "object",
            "required": [
                "end_date",
                "name",
                "start_date"
            ],
            "properties": {
                "description": {
                    "type": "string",
                    "example": "Special holiday discounts"
                },
                "discount": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "example": [
                        "[{\"value\":10",
                        "\"type\":\"percentage\"}]"
                    ]
                },
                "end_date": {
                    "type": "string",
                    "example": "2024-12-31"
                },
                "name": {
                    "type": "string",
                    "example": "Holiday Sale"
                },
                "product_name": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "example": [
                        "[\"Smartphone\"",
                        " \"Laptop\"]"
                    ]
                },
                "published": {
                    "type": "boolean",
                    "example": true
                },
                "quota": {
                    "type": "integer",
                    "example": 100
                },
                "start_date": {
                    "type": "string",
                    "example": "2024-12-01"
                },
                "status": {
                    "type": "boolean",
                    "example": true
                },
                "type": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "example": [
                        "[\"discount\"",
                        " \"bundle\"]"
                    ]
                }
            }
        },
        "models.RegisterRequest": {
            "type": "object",
            "required": [
                "email",
                "name",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string",
                    "example": "johndoe@example.com"
                },
                "name": {
                    "type": "string",
                    "example": "John Doe"
                },
                "password": {
                    "type": "string",
                    "minLength": 8,
                    "example": "password123"
                }
            }
        },
        "models.StockRequest": {
            "type": "object",
            "required": [
                "product_id",
                "quantity",
                "type"
            ],
            "properties": {
                "product_id": {
                    "type": "integer"
                },
                "quantity": {
                    "type": "integer",
                    "minimum": 1
                },
                "type": {
                    "type": "string",
                    "enum": [
                        "in",
                        "out"
                    ]
                }
            }
        },
        "models.SuccessResponse": {
            "type": "object",
            "properties": {
                "data": {},
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "utils.ErrorResponse": {
            "type": "object",
            "properties": {
                "error_msg": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                }
            }
        },
        "utils.PaginationResponse": {
            "type": "object",
            "properties": {
                "data": {},
                "limit": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "page": {
                    "type": "integer"
                },
                "total_items": {
                    "type": "integer"
                },
                "total_pages": {
                    "type": "integer"
                }
            }
        },
        "utils.ResponseOK": {
            "type": "object",
            "properties": {
                "data": {},
                "message": {
                    "type": "string"
                }
            }
        },
        "utils.StockResponse": {
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "product_id": {
                    "type": "integer"
                },
                "product_name": {
                    "type": "string"
                },
                "product_stock": {
                    "type": "integer"
                },
                "updated_at": {
                    "type": "string"
                },
                "variant": {}
            }
        }
    },
    "securityDefinitions": {
        "Authentication": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        },
        "UserID": {
            "type": "apiKey",
            "name": "User-ID",
            "in": "header"
        },
        "UserRole": {
            "type": "apiKey",
            "name": "User-Role",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "Dashboard Ecommerce Team 2",
        Description:      "API for managing Ecommerce",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package helper

import (
        // "crypto/rand"
        // "encoding/hex"

        "golang.org/x/crypto/bcrypt"
)

func CheckPassword(inputPassword, storedPassword string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(storedPassword), []byte(inputPassword))
        return err == nil
}</span>

func HashPassword(password string) string <span class="cov8" title="1">{
        bytes, _ := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        return string(bytes)
}</span>

// func GenerateToken() string {
//         token := make([]byte, 32)
//         _, err := rand.Read(token)
//         if err != nil {
//                 panic("failed to generate token")
//         }
//         return hex.EncodeToString(token)
// }
</pre>
		
		<pre class="file" id="file16" style="display: none">package helper

import "strconv"

func Contains(slice []string, str string) bool <span class="cov0" title="0">{
        for _, item := range slice </span><span class="cov0" title="0">{
                if item == str </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func StringToBool(str string) bool <span class="cov0" title="0">{
        convBool, _ := strconv.ParseBool(str)
        return convBool
}</span>

func StringToInt(num string) int <span class="cov0" title="0">{
        convInt, _ := strconv.Atoi(num)
        return convInt
}</span>
func IntToString(num int) string <span class="cov0" title="0">{
        convStr := strconv.Itoa(num)
        return convStr
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package helper

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "path/filepath"
)

// ApiResponse struct tetap dipertahankan
type ApiResponse struct {
        Success bool   `json:"success"`
        Message string `json:"message"`
        Data    struct {
                FileId      string `json:"fileId"`
                Name        string `json:"name"`
                Size        int    `json:"size"`
                VersionInfo struct {
                        Id   string `json:"id"`
                        Name string `json:"name"`
                } `json:"versionInfo"`
                FilePath     string      `json:"filePath"`
                Url          string      `json:"url"`
                FileType     string      `json:"fileType"`
                Height       int         `json:"height"`
                Width        int         `json:"width"`
                ThumbnailUrl string      `json:"thumbnailUrl"`
                AITags       interface{} `json:"AITags"`
        } `json:"data"`
}

// Helper function untuk upload gambar dan mendapatkan respons lengkap
func UploadImage(file *multipart.FileHeader) (string, error) <span class="cov0" title="0">{
        var apiResponse ApiResponse

        f, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to open file: %v", err)
        }</span>
        <span class="cov0" title="0">defer f.Close()

        body := &amp;bytes.Buffer{}
        writer := multipart.NewWriter(body)

        part, err := writer.CreateFormFile("image", filepath.Base(file.Filename))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create form file: %v", err)
        }</span>
        <span class="cov0" title="0">_, err = io.Copy(part, f)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to copy file content: %v", err)
        }</span>

        <span class="cov0" title="0">err = writer.Close()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to close writer: %v", err)
        }</span>

        <span class="cov0" title="0">request, err := http.NewRequest("POST", "https://cdn-lumoshive-academy.vercel.app/api/v1/upload", body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %v", err)
        }</span>
        <span class="cov0" title="0">request.Header.Add("Content-Type", writer.FormDataContentType())

        client := &amp;http.Client{}
        response, err := client.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request: %v", err)
        }</span>
        <span class="cov0" title="0">defer response.Body.Close()

        resBody, err := io.ReadAll(response.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read response: %v", err)
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(resBody, &amp;apiResponse)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to unmarshal response: %v", err)
        }</span>

        <span class="cov0" title="0">if !apiResponse.Success </span><span class="cov0" title="0">{
                return "", fmt.Errorf("upload failed: %s", apiResponse.Message)
        }</span>

        <span class="cov0" title="0">return apiResponse.Data.Url, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package helper

import (
        "log"
        "os"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

func InitZapLogger() (*zap.Logger, error) <span class="cov8" title="1">{

        logLevel := zap.InfoLevel

        encoderConfig := zapcore.EncoderConfig{
                TimeKey:        "T",
                LevelKey:       "L",
                MessageKey:     "M",
                CallerKey:      "C",
                EncodeTime:     zapcore.ISO8601TimeEncoder,
                EncodeLevel:    zapcore.CapitalLevelEncoder,
                EncodeDuration: zapcore.StringDurationEncoder,
                EncodeCaller:   zapcore.ShortCallerEncoder,
        }

        file, err := os.OpenFile("app.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf("Failed to open log file: %v", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">core := zapcore.NewTee(

                zapcore.NewCore(
                        zapcore.NewJSONEncoder(encoderConfig),
                        zapcore.AddSync(file),
                        logLevel,
                ),

                zapcore.NewCore(
                        zapcore.NewConsoleEncoder(encoderConfig),
                        zapcore.AddSync(os.Stdout),
                        logLevel,
                ),
        )

        logger := zap.New(core)
        logger.Info("Logger initialized successfully")

        return logger, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package helper

import "time"

func PointerToTime(t time.Time) *time.Time <span class="cov0" title="0">{
        return &amp;t
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package helper

import (
        "github.com/gin-gonic/gin"
)

type HTTPResponse struct {
        ErrorMsg   string      `json:"error_msg,omitempty"`
        Message    string      `json:"message,omitempty"`
        Page       int         `json:"page,omitempty"`
        Limit      int         `json:"limit,omitempty"`
        TotalItems int         `json:"total_items,omitempty"`
        TotalPages int         `json:"total_pages,omitempty"`
        Data       interface{} `json:"data,omitempty"`
}

func ResponseOK(c *gin.Context, data interface{}, message string, httpStatusCode int) <span class="cov8" title="1">{
        c.JSON(httpStatusCode, HTTPResponse{
                Message: message,
                Data:    data,
        })
}</span>
func ResponseOKPagination(c *gin.Context, data interface{}, message string, page, limit, totalItems, totalPages, httpStatusCode int) <span class="cov0" title="0">{
        c.JSON(httpStatusCode, HTTPResponse{
                Message: message,
                Page: page,
                Limit: limit,
                TotalItems: totalItems,
                TotalPages: totalPages,
                Data:    data,
        })
}</span>

func ResponseError(c *gin.Context, errorMsg string, message string, httpStatusCode int) <span class="cov8" title="1">{
        c.JSON(httpStatusCode, HTTPResponse{
                ErrorMsg: errorMsg,
                Message:  message,
        })
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package helper

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "fmt"
        "strings"
        "time"
)

func GenerateToken(userID string, secretKey string) string <span class="cov0" title="0">{
        // Gabungkan data user
        data := fmt.Sprintf("%s:%d", userID, time.Now().Unix())

        // Buat hash HMAC menggunakan SHA-256
        h := hmac.New(sha256.New, []byte(secretKey))
        h.Write([]byte(data))
        signature := base64.URLEncoding.EncodeToString(h.Sum(nil))

        // Encode data ke Base64
        tokenData := base64.URLEncoding.EncodeToString([]byte(data))

        // Gabungkan data dan tanda tangan
        return fmt.Sprintf("%s.%s", tokenData, signature)
}</span>

func ValidationToken(token string, secretKey string) (bool, string) <span class="cov0" title="0">{
        // Pisahkan token menjadi data dan signature
        parts := strings.Split(token, ".")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return false, "Invalid token format"
        }</span>

        <span class="cov0" title="0">tokenData, signature := parts[0], parts[1]

        // Decode data dari Base64
        data, err := base64.URLEncoding.DecodeString(tokenData)
        if err != nil </span><span class="cov0" title="0">{
                return false, "Invalid token data"
        }</span>

        // Buat ulang signature untuk validasi
        <span class="cov0" title="0">h := hmac.New(sha256.New, []byte(secretKey))
        h.Write(data)
        expectedSignature := base64.URLEncoding.EncodeToString(h.Sum(nil))

        // Validasi signature
        if signature != expectedSignature </span><span class="cov0" title="0">{
                return false, "Invalid token signature"
        }</span>

        <span class="cov0" title="0">return true, string(data)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package helper

import (
        // "regexp"
        "strings"

        "github.com/go-playground/validator/v10"
)

type Validator struct {
        validate *validator.Validate
}

// NewValidator membuat instance Validator dengan registrasi validator kustom
func NewValidator() *Validator <span class="cov0" title="0">{
        v := validator.New()

        // Daftarkan validasi regex kustom
        // v.RegisterValidation("regex", func(fl validator.FieldLevel) bool {
        //         pattern := fl.Param() // Ambil pattern regex dari parameter
        //         value := fl.Field().String()

        //         matched, err := regexp.MatchString(pattern, value)
        //         if err != nil {
        //                 return false
        //         }
        //         return matched
        // })

        return &amp;Validator{validate: v}
}</span>

// ValidateStruct melakukan validasi terhadap struct yang diberikan
func (v *Validator) ValidateStruct(data interface{}) error <span class="cov0" title="0">{
        return v.validate.Struct(data) // Validasi menggunakan rules yang telah didaftarkan
}</span>

// FormatValidationError mengubah error validasi menjadi pesan yang lebih ramah
func FormatValidationError(err error) string <span class="cov0" title="0">{
        errorMessages := map[string]string{
                "CategoryID_required": "Category ID is required",
                "CategoryID_gt":       "Category ID must be greater than 0",
                "Name_required":       "Name is required",
                "Name_min":            "Name must have at least 3 characters",
                "Name_regex":          "Name must only contain letters and spaces",
                "Images_url":          "Each image must be a valid URL",
                "Stock_gt":            "Stock must be greater than 0",
                "Price_gt":            "Price must be greater than 0",
                "Quantity_gt":         "Quantity must be greater than 0",
                "ProductID_gt":        "ProductID must be greater than 0",
                "Type_oneof":          "Type must be 'in' or 'out'",
        }

        var errMessages []string

        if validationErrors, ok := err.(validator.ValidationErrors); ok </span><span class="cov0" title="0">{
                for _, ve := range validationErrors </span><span class="cov0" title="0">{

                        key := ve.Field() + "_" + ve.Tag()

                        if message, found := errorMessages[key]; found </span><span class="cov0" title="0">{
                                errMessages = append(errMessages, message)
                        }</span> else<span class="cov0" title="0"> {

                                errMessages = append(errMessages, ve.Field()+" is invalid: "+ve.Tag())
                        }</span>
                }
        }

        <span class="cov0" title="0">return strings.Join(errMessages, ", ")</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package infra

import (
        "dashboard-ecommerce-team2/config"
        "dashboard-ecommerce-team2/controller"
        "dashboard-ecommerce-team2/database"
        "dashboard-ecommerce-team2/helper"
        "dashboard-ecommerce-team2/middleware"
        "dashboard-ecommerce-team2/repository"
        "dashboard-ecommerce-team2/service"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type ServiceContext struct {
        Cfg        config.Configuration
        DB         *gorm.DB
        Ctl        controller.Controller
        Log        *zap.Logger
        Cacher     database.Cacher
        Middleware middleware.Middleware
        Repo       *repository.Repository
}

var MockTest *ServiceContext

func NewServiceContext() (*ServiceContext, error) <span class="cov0" title="0">{

        handlerError := func(err error) (*ServiceContext, error) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // instance config
        <span class="cov0" title="0">config, err := config.ReadConfig()
        if err != nil </span><span class="cov0" title="0">{
                handlerError(err)
        }</span>

        // instance looger
        <span class="cov0" title="0">log, err := helper.InitZapLogger()
        if err != nil </span><span class="cov0" title="0">{
                handlerError(err)
        }</span>

        // instance database
        <span class="cov0" title="0">db, err := database.InitDB(config)
        if err != nil </span><span class="cov0" title="0">{
                handlerError(err)
        }</span>

        <span class="cov0" title="0">rdb := database.NewCacher(config, 60*60)

        middleware := middleware.NewMiddleware(log, rdb)

        // instance repository
        repository := repository.NewRepository(db, log)

        // instance service
        service := service.NewService(repository, log)

        // instance controller
        Ctl := controller.NewController(service, log, rdb, config)

        MockTest = &amp;ServiceContext{Cfg: config, DB: db, Ctl: *Ctl, Log: log, Cacher: rdb, Middleware: middleware, Repo: &amp;repository}

        return &amp;ServiceContext{Cfg: config, DB: db, Ctl: *Ctl, Log: log, Cacher: rdb, Middleware: middleware, Repo: &amp;repository}, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package main

import (
        "context"
        _ "dashboard-ecommerce-team2/docs"
        "dashboard-ecommerce-team2/infra"
        "dashboard-ecommerce-team2/routes"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        _ "dashboard-ecommerce-team2/docs"
)

// @title Dashboard Ecommerce Team 2
// @version 1.0
// @description API for managing Ecommerce
// @termsOfService http://example.com/terms/
// @contact.name API Support
// @contact.url http://example.com/support
// @contact.email support@example.com
// @license.name MIT
// @license.url https://opensource.org/licenses/MIT
// @host localhost:8080
// @BasePath /
// @securityDefinitions.apikey Authentication
// @in header
// @name Authorization
// @securityDefinitions.apikey UserID
// @in header
// @name User-ID
// @securityDefinitions.apikey UserRole
// @in header
// @name User-Role

func main() <span class="cov0" title="0">{
        ctx, err := infra.NewServiceContext()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("can't init service context %w", err)
        }</span>

        <span class="cov0" title="0">r := routes.NewRoutes(*ctx)

        srv := &amp;http.Server{
                Addr:    ":8080",
                Handler: r,
        }

        go func() </span><span class="cov0" title="0">{
                // Start the server
                log.Printf("Server running on port 8080")
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("listen: %s\n", err)
                }</span>
        }()

        // Wait for interrupt signal to gracefully shutdown the server with a timeout of 5 seconds
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit
        log.Println("Shutdown Server ...")

        // Create a timeout context for graceful shutdown
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Attempt to gracefully shutdown the server
        if err := srv.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Server Shutdown:", err)
        }</span>

        // Catching context timeout
        <span class="cov0" title="0">select </span>{
        case &lt;-shutdownCtx.Done():<span class="cov0" title="0">
                log.Println("Timeout of 5 seconds.")</span>
        }

        <span class="cov0" title="0">log.Println("Server exiting")</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package middleware

import (
        "dashboard-ecommerce-team2/database"
        "dashboard-ecommerce-team2/helper"
        "net/http"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

type Middleware struct {
        log    *zap.Logger
        Cacher database.Cacher
}

func NewMiddleware(log *zap.Logger, cacher database.Cacher) Middleware <span class="cov8" title="1">{
        return Middleware{
                log:    log,
                Cacher: cacher,
        }
}</span>

func (m *Middleware) Authentication() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                token := c.GetHeader("Authorization")
                if token == "" </span><span class="cov0" title="0">{
                        helper.ResponseError(c, "Token is required", "Unauthorized", http.StatusUnauthorized)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">userID := c.GetHeader("User-ID")
                if userID == "" </span><span class="cov0" title="0">{
                        helper.ResponseError(c, "User-ID is required", "Unauthorized", http.StatusUnauthorized)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">m.log.Info("Authenticating user", zap.String("userID", userID), zap.String("token", token))

                storedToken, err := m.Cacher.Get(userID)
                if err != nil </span><span class="cov0" title="0">{
                        helper.ResponseError(c, "Failed to retrieve token", "Server error", http.StatusInternalServerError)
                        c.Abort()
                        return
                }</span>
                <span class="cov0" title="0">m.log.Info("Authenticating user", zap.String("storedToken", storedToken), zap.String("token", token))

                if storedToken == "" || storedToken != token </span><span class="cov0" title="0">{
                        helper.ResponseError(c, "Invalid token", "Unauthorized", http.StatusUnauthorized)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

func (m *Middleware) RoleAuthorization(requiredRoles string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                role := c.GetHeader("User-Role")
                if role == "" </span><span class="cov0" title="0">{
                        helper.ResponseError(c, "Roles are required", "Unauthorized", http.StatusUnauthorized)
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">m.log.Info("Authorizing user role", zap.String("role", role), zap.String("requiredRoles", requiredRoles))

                if role == requiredRoles </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">helper.ResponseError(c, "Insufficient permissions", "Unauthorized", http.StatusUnauthorized)
                c.Abort()</span>
        }
}</pre>
		
		<pre class="file" id="file26" style="display: none">package models

import (
        "dashboard-ecommerce-team2/helper"
        "database/sql/driver"
        "encoding/json"
        "errors"
        "mime/multipart"
        "time"

        "gorm.io/gorm"
)

type BannerGetValue struct {
        ID          int                   `json:"id" form:"id" gorm:"primaryKey" swaggerignore:"true"`
        ImagePath   *multipart.FileHeader `json:"image_path" form:"image_path" binding:"required" swaggerignore:"true"`
        Title       string                `json:"title" form:"title" gorm:"size:255;not null" binding:"required" example:"Spring Sale 2024"`
        Type        []string              `json:"type" form:"type" gorm:"type:jsonb;default:'[]'" binding:"required" example:"[\"seasonal\", \"promo\"]"`
        PathPage    string                `json:"path_page" form:"path_page" gorm:"size:255;not null" binding:"required" example:"/spring-sale"`
        ReleaseDate *time.Time            `json:"release_date" form:"release_date" gorm:"type:date" binding:"required" example:"2024-03-01"`
        EndDate     *time.Time            `json:"end_date" form:"end_date" gorm:"type:date" binding:"required" example:"2024-03-31"`
        Published   bool                  `json:"published" form:"published" gorm:"default:false" example:"true"`
        CreatedAt   time.Time             `json:"created_at" form:"created_at" gorm:"autoCreateTime" swaggerignore:"true"`
        UpdatedAt   time.Time             `json:"updated_at" form:"updated_at" gorm:"autoUpdateTime" swaggerignore:"true"`
        DeletedAt   *gorm.DeletedAt       `json:"deleted_at,omitempty" form:"deleted_at" gorm:"index" swaggerignore:"true"`
}

type Banner struct {
        ID          int             `json:"id" form:"id" gorm:"primaryKey;autoIncrement" swaggerignore:"true"`
        Image       string          `json:"image" form:"image" gorm:"size:255;not null" binding:"omitempty" example:"/images/banner1.png"`
        Title       string          `json:"title" form:"title" gorm:"size:255;not null" binding:"omitempty" example:"Spring Sale 2024"`
        Type        JSONB           `json:"type" form:"type" gorm:"type:jsonb;default:'[]'" binding:"omitempty" swaggertype:"array,string" example:"[\"seasonal\", \"promo\"]"`
        PathPage    string          `json:"path_page" form:"path_page" gorm:"size:255;not null" binding:"omitempty" example:"/spring-sale"`
        ReleaseDate *time.Time      `json:"release_date" form:"release_date" gorm:"type:date" binding:"omitempty" example:"2024-03-01"`
        EndDate     *time.Time      `json:"end_date" form:"end_date" gorm:"type:date" binding:"omitempty" example:"2024-03-31"`
        Published   bool            `json:"published" form:"published" gorm:"default:false" example:"true"`
        CreatedAt   time.Time       `json:"created_at" form:"created_at" gorm:"autoCreateTime" swaggerignore:"true"`
        UpdatedAt   time.Time       `json:"updated_at" form:"updated_at" gorm:"autoUpdateTime" swaggerignore:"true"`
        DeletedAt   *gorm.DeletedAt `json:"deleted_at,omitempty" form:"deleted_at" gorm:"index" swaggerignore:"true"`
}

func (b *Banner) CopyBannerGetValueToBanner(urlImagae string, getValue BannerGetValue) (Banner, error) <span class="cov0" title="0">{
        Timenow := time.Now()
        var Tojsonb JSONB
        err := json.Unmarshal([]byte(getValue.Type[0]), &amp;Tojsonb)
        if err != nil </span><span class="cov0" title="0">{
                return Banner{}, err
        }</span>

        <span class="cov0" title="0">return Banner{
                ID:          getValue.ID,
                Title:       getValue.Title,
                Image:       urlImagae,
                Type:        Tojsonb,
                PathPage:    getValue.PathPage,
                ReleaseDate: getValue.ReleaseDate,
                EndDate:     getValue.EndDate,
                Published:   getValue.Published,
                CreatedAt:   Timenow,
                UpdatedAt:   Timenow,
                DeletedAt:   nil,
        }, nil</span>
}

type JSONB []interface{}

var Timenow = time.Now()

// Value implements the driver.Valuer interface for JSONB to store as JSON.
func (a JSONB) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(a)
}</span>

// Scan implements the sql.Scanner interface for JSONB to retrieve JSON data.
func (a *JSONB) Scan(value interface{}) error <span class="cov0" title="0">{
        b, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("failed to cast value to []byte")
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(b, &amp;a)</span>
}

// BannerSeed provides a seed data function for the Banner model.
func BannerSeed() []Banner <span class="cov0" title="0">{
        return []Banner{
                {
                        Image:       "/images/banner1.png",
                        Title:       "Winter Sale",
                        Type:        JSONB{"seasonal", "promo"},
                        PathPage:    "/sale",
                        ReleaseDate: helper.PointerToTime(time.Date(2024, 1, 15, 0, 0, 0, 0, time.UTC)),
                        EndDate:     helper.PointerToTime(time.Date(2024, 1, 31, 0, 0, 0, 0, time.UTC)),
                        Published:   true,
                        CreatedAt:   Timenow,
                        UpdatedAt:   Timenow,
                },
                {
                        Image:       "/images/banner2.png",
                        Title:       "Spring Promo 2000",
                        Type:        JSONB{"promo"},
                        PathPage:    "/promo",
                        ReleaseDate: helper.PointerToTime(time.Date(2024, 3, 1, 0, 0, 0, 0, time.UTC)),
                        EndDate:     helper.PointerToTime(time.Date(2024, 3, 15, 0, 0, 0, 0, time.UTC)),
                        Published:   false,
                        CreatedAt:   Timenow,
                        UpdatedAt:   Timenow,
                },
                {
                        Image:       "/images/banner3.png",
                        Title:       "Black Friday Deals",
                        Type:        JSONB{"discount", "exclusive"},
                        PathPage:    "/black-friday",
                        ReleaseDate: helper.PointerToTime(time.Date(2024, 11, 25, 0, 0, 0, 0, time.UTC)),
                        EndDate:     helper.PointerToTime(time.Date(2024, 11, 29, 0, 0, 0, 0, time.UTC)),
                        Published:   true,
                        CreatedAt:   Timenow,
                        UpdatedAt:   Timenow,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package models

import (
        "encoding/json"
        "time"

        "gorm.io/gorm"
)

type Category struct {
        ID        int             `json:"id" gorm:"primaryKey" swaggerignore:"true"`
        Name      string          `json:"name" gorm:"size:50;unique;not null" binding:"required" example:"Electronics"`
        Variant   json.RawMessage `json:"variant" gorm:"type:jsonb;default:'{}'" example:"{\"color\":\"red\", \"size\":\"medium\"}"`
        Icon      string          `json:"icon" form:"icon" gorm:"size:255;not null" binding:"omitempty" example:"/icon/category.png"`
        CreatedAt time.Time       `json:"created_at" gorm:"autoCreateTime" swaggerignore:"true"`
        UpdatedAt time.Time       `json:"updated_at" gorm:"autoUpdateTime" swaggerignore:"true"`
        DeletedAt *gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty" swaggerignore:"true"`
}

func CategorySeed() []Category <span class="cov0" title="0">{
        return []Category{
                {
                        Name:      "Electronics",
                        Icon:      "/icon/electronics.png",
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
                {
                        Name:      "Fashion",
                        Icon:      "/icon/fashion.png",
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
                {
                        Name:      "Home &amp; Kitchen",
                        Icon:      "/icon/home-kitchen.png",
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
                {
                        Name:      "Books",
                        Icon:      "/icon/books.png",
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
                {
                        Name:      "Toys &amp; Games",
                        Icon:      "/icon/toys-games.png",
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package models

import "time"

type Order struct {
        ID              int       `json:"id" gorm:"primaryKey" swaggerignore:"true"`
        UserID          int       `json:"user_id" gorm:"not null" binding:"required" example:"1"`
        TotalAmount     float64   `json:"total_amount" gorm:"type:decimal(10,2);not null" binding:"required" example:"150.75"`
        PaymentMethod   string    `json:"payment_method" gorm:"size:20;not null" binding:"required" example:"credit_card"`
        ShippingAddress string    `json:"shipping_address" gorm:"size:255" binding:"omitempty" example:"123 Main St"`
        Status          string    `json:"status" gorm:"size:20;check:status IN ('pending','shipped','completed','canceled');default:'created'" binding:"required" example:"pending"`
        CreatedAt       time.Time `json:"created_at" gorm:"autoCreateTime" swaggerignore:"true"`
        UpdatedAt       time.Time `json:"updated_at" gorm:"autoUpdateTime" swaggerignore:"true"`
}

type OrderItem struct {
        ID        int     `json:"id" gorm:"primaryKey" swaggerignore:"true"`
        OrderID   int     `json:"order_id" gorm:"not null" binding:"required" example:"1"`
        ProductID int     `json:"product_id" gorm:"not null" binding:"required" example:"101"`
        Quantity  int     `json:"quantity" gorm:"not null" binding:"required" example:"2"`
        Price     float64 `json:"price" gorm:"type:decimal(10,2);not null" binding:"required" example:"75.00"`
        Total     float64 `json:"total" gorm:"type:decimal(10,2);not null" binding:"required"`
}

type OrderDetailResponse struct {
        Order *Order      `json:"order"`
        Items []OrderItem `json:"items"`
}

func OrderSeed() []Order <span class="cov0" title="0">{
        return []Order{
                {
                        UserID:          1,
                        TotalAmount:     150.75,
                        PaymentMethod:   "credit_card",
                        ShippingAddress: "123 Main St",
                        Status:          "pending",
                        CreatedAt:       time.Date(2024, time.January, 15, 12, 0, 0, 0, time.UTC),
                        UpdatedAt:       time.Date(2024, time.January, 15, 12, 0, 0, 0, time.UTC),
                },
                {
                        UserID:          2,
                        TotalAmount:     300.00,
                        PaymentMethod:   "paypal",
                        ShippingAddress: "456 Elm St",
                        Status:          "shipped",
                        CreatedAt:       time.Date(2024, time.February, 15, 12, 0, 0, 0, time.UTC),
                        UpdatedAt:       time.Date(2024, time.February, 16, 12, 0, 0, 0, time.UTC),
                },
                {
                        UserID:          3,
                        TotalAmount:     500.50,
                        PaymentMethod:   "debit_card",
                        ShippingAddress: "789 Oak St",
                        Status:          "completed",
                        CreatedAt:       time.Date(2024, time.March, 15, 12, 0, 0, 0, time.UTC),
                        UpdatedAt:       time.Date(2024, time.March, 16, 12, 0, 0, 0, time.UTC),
                },
                {
                        UserID:          4,
                        TotalAmount:     175.25,
                        PaymentMethod:   "debit_card",
                        ShippingAddress: "123 Pine St",
                        Status:          "canceled",
                        CreatedAt:       time.Date(2024, time.April, 15, 12, 0, 0, 0, time.UTC),
                        UpdatedAt:       time.Date(2024, time.April, 15, 12, 0, 0, 0, time.UTC),
                },
                {
                        UserID:          5,
                        TotalAmount:     250.00,
                        PaymentMethod:   "bank_transfer",
                        ShippingAddress: "321 Birch St",
                        Status:          "pending",
                        CreatedAt:       time.Date(2024, time.May, 15, 12, 0, 0, 0, time.UTC),
                        UpdatedAt:       time.Date(2024, time.May, 15, 12, 0, 0, 0, time.UTC),
                },
                {
                        UserID:          6,
                        TotalAmount:     100.75,
                        PaymentMethod:   "cash",
                        ShippingAddress: "654 Maple St",
                        Status:          "shipped",
                        CreatedAt:       time.Date(2024, time.June, 15, 12, 0, 0, 0, time.UTC),
                        UpdatedAt:       time.Date(2024, time.June, 16, 12, 0, 0, 0, time.UTC),
                },
                {
                        UserID:          7,
                        TotalAmount:     400.50,
                        PaymentMethod:   "credit_card",
                        ShippingAddress: "987 Cedar St",
                        Status:          "completed",
                        CreatedAt:       time.Date(2024, time.July, 15, 12, 0, 0, 0, time.UTC),
                        UpdatedAt:       time.Date(2024, time.July, 16, 12, 0, 0, 0, time.UTC),
                },
                {
                        UserID:          8,
                        TotalAmount:     300.25,
                        PaymentMethod:   "debit_card",
                        ShippingAddress: "213 Ash St",
                        Status:          "canceled",
                        CreatedAt:       time.Date(2024, time.August, 15, 12, 0, 0, 0, time.UTC),
                        UpdatedAt:       time.Date(2024, time.August, 15, 12, 0, 0, 0, time.UTC),
                },
                {
                        UserID:          9,
                        TotalAmount:     275.00,
                        PaymentMethod:   "paypal",
                        ShippingAddress: "546 Spruce St",
                        Status:          "pending",
                        CreatedAt:       time.Date(2024, time.September, 15, 12, 0, 0, 0, time.UTC),
                        UpdatedAt:       time.Date(2024, time.September, 15, 12, 0, 0, 0, time.UTC),
                },
                {
                        UserID:          10,
                        TotalAmount:     125.50,
                        PaymentMethod:   "cash",
                        ShippingAddress: "879 Willow St",
                        Status:          "shipped",
                        CreatedAt:       time.Date(2024, time.October, 15, 12, 0, 0, 0, time.UTC),
                        UpdatedAt:       time.Date(2024, time.October, 16, 12, 0, 0, 0, time.UTC),
                },
                {
                        UserID:          11,
                        TotalAmount:     500.00,
                        PaymentMethod:   "bank_transfer",
                        ShippingAddress: "210 Poplar St",
                        Status:          "completed",
                        CreatedAt:       time.Date(2024, time.November, 15, 12, 0, 0, 0, time.UTC),
                        UpdatedAt:       time.Date(2024, time.November, 16, 12, 0, 0, 0, time.UTC),
                },
                {
                        UserID:          12,
                        TotalAmount:     350.00,
                        PaymentMethod:   "credit_card",
                        ShippingAddress: "432 Sycamore St",
                        Status:          "completed",
                        CreatedAt:       time.Date(2024, time.December, 15, 12, 0, 0, 0, time.UTC),
                        UpdatedAt:       time.Date(2024, time.December, 15, 12, 0, 0, 0, time.UTC),
                },
        }
}</span>

func OrderItemSeed() []OrderItem <span class="cov0" title="0">{
        return []OrderItem{
                {
                        OrderID:   1,
                        ProductID: 1, // Smartphone
                        Quantity:  2,
                        Price:     699.99,
                        Total:     1399.98,
                },
                {
                        OrderID:   2,
                        ProductID: 2, // Laptop
                        Quantity:  3,
                        Price:     1299.99,
                        Total:     3899.97,
                },
                {
                        OrderID:   3,
                        ProductID: 3, // Smartwatch
                        Quantity:  5,
                        Price:     199.99,
                        Total:     999.95,
                },
                {
                        OrderID:   4,
                        ProductID: 4, // Headphones
                        Quantity:  1,
                        Price:     89.99,
                        Total:     89.99,
                },
                {
                        OrderID:   5,
                        ProductID: 1, // Smartphone
                        Quantity:  3,
                        Price:     699.99,
                        Total:     2099.97,
                },
                {
                        OrderID:   6,
                        ProductID: 2, // Laptop
                        Quantity:  2,
                        Price:     1299.99,
                        Total:     2599.98,
                },
                {
                        OrderID:   7,
                        ProductID: 3, // Smartwatch
                        Quantity:  4,
                        Price:     199.99,
                        Total:     799.96,
                },
                {
                        OrderID:   8,
                        ProductID: 4, // Headphones
                        Quantity:  3,
                        Price:     89.99,
                        Total:     269.97,
                },
                {
                        OrderID:   9,
                        ProductID: 1, // Smartphone
                        Quantity:  1,
                        Price:     699.99,
                        Total:     699.99,
                },
                {
                        OrderID:   10,
                        ProductID: 2, // Laptop
                        Quantity:  1,
                        Price:     1299.99,
                        Total:     1299.99,
                },
                {
                        OrderID:   11,
                        ProductID: 3, // Smartwatch
                        Quantity:  3,
                        Price:     199.99,
                        Total:     599.97,
                },
                {
                        OrderID:   12,
                        ProductID: 4, // Headphones
                        Quantity:  2,
                        Price:     89.99,
                        Total:     179.98,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package models

import (
        "database/sql/driver"
        "encoding/json"
        "fmt"
        "time"

        "gorm.io/gorm"
)

type Product struct {
        ID          int         `json:"id" gorm:"primaryKey" swaggerignore:"true"`
        CategoryID  int         `json:"category_id" form:"category_id" gorm:"not null" binding:"required,gt=0" example:"1"`
        Name        string      `json:"name" form:"name" gorm:"size:100;not null" binding:"required,min=3" example:"Smartphone"`
        CodeProduct string      `json:"code_product" form:"code_product" gorm:"size:100;unique;not null" binding:"required" example:"SPH-001"`
        Images      StringArray `json:"images" form:"file" gorm:"type:jsonb;default:'[]'" binding:"omitempty,dive,url" example:"[\"/images/smartphone1.png\"]" swaggerignore:"true"`
        Description string      `json:"description" form:"description" binding:"omitempty" example:"Latest smartphone with advanced features"`
        Stock       int         `json:"stock" form:"stock" gorm:"not null" binding:"required,gt=0" example:"50"`
        Price       float64     `json:"price" form:"price" gorm:"type:decimal(10,2);not null" binding:"required,gt=0" example:"699.99"`
        Published   bool        `json:"published" form:"published" gorm:"type:boolean;default:false" example:"true"`
        CreatedAt   time.Time   `json:"created_at" gorm:"autoCreateTime" swaggerignore:"true"`
        UpdatedAt   time.Time   `json:"updated_at" gorm:"autoUpdateTime" swaggerignore:"true"`
}
type ProductWithCategory struct {
        ID           int         `json:"id"`
        CategoryName string      `json:"category_name"`
        Name         string      `json:"name"`
        CodeProduct  string      `json:"code_product"`
        Images       StringArray `json:"images"`
        Description  string      `json:"description"`
        Stock        int         `json:"stock"`
        Price        float64     `json:"price"`
        Published    bool        `json:"published"`
}

type ProductID struct {
        ID           int             `json:"id"`
        CategoryName string          `json:"category_name"`
        Variant      json.RawMessage `json:"variant"`
        Name         string          `json:"name"`
        CodeProduct  string          `json:"code_product"`
        Images       StringArray     `json:"images"`
        Description  string          `json:"description"`
        Stock        int             `json:"stock"`
        Price        float64         `json:"price"`
        Published    bool            `json:"published"`
}

type StringArray []string

func (s *StringArray) Scan(value interface{}) error <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                *s = nil
                return nil
        }</span>
        <span class="cov0" title="0">byteValue, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to scan StringArray")
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(byteValue, s)</span>
}

func (s StringArray) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(s)
}</span>

func (v *Product) BeforeSave(tx *gorm.DB) (err error) <span class="cov0" title="0">{
        v.CreatedAt = time.Now()
        v.UpdatedAt = time.Now()

        return nil
}</span>

type Stock struct {
        ID        uint      `gorm:"primaryKey" json:"id"`
        ProductID uint      `gorm:"not null" json:"product_id" binding:"required,gt=0"`
        Type      string    `gorm:"size:10;check:type IN ('in','out')" json:"type"`
        Quantity  int       `json:"quantity" binding:"required,gt=0"`
        CreatedAt time.Time `gorm:"autoCreateTime" json:"created_at"`
        UpdatedAt time.Time `gorm:"autoUpdateTime" json:"updated_at"`
}

func (v *Stock) BeforeSave(tx *gorm.DB) (err error) <span class="cov0" title="0">{
        v.CreatedAt = time.Now()
        v.UpdatedAt = time.Now()
        return nil
}</span>

type StockRequest struct {
        ProductID uint      `json:"product_id" binding:"required,gt=0"`
        Type      string    `json:"type" binding:"required,oneof=in out"`
        Quantity  int       `json:"quantity" binding:"required,min=1"`
        CreatedAt time.Time `json:"-"`
        UpdatedAt time.Time `json:"-"`
}

type StockResponse struct {
        ID           uint            `json:"id"`
        ProductID    uint            `json:"product_id"`
        Type         string          `json:"description"`
        Quantity     int             `json:"quantity"`
        ProductName  string          `json:"product_name"`
        Variant      json.RawMessage `json:"variant"`
        CreatedAt    time.Time       `json:"created_at"`
        UpdatedAt    time.Time       `json:"updated_at"`
}

type BestProduct struct {
        ProductID int    `json:"product_id"`
        Name      string `json:"name"`
        Total     int    `json:"total"`
}

func ProductSeed() []Product <span class="cov0" title="0">{
        return []Product{
                {
                        CategoryID:  1,
                        Name:        "Smartphone",
                        CodeProduct: "SPH-001",
                        Images:      []string{"/images/smartphone1.png", "/images/smartphone2.png"},
                        Description: "Latest smartphone with advanced features",
                        Stock:       50,
                        Price:       699.99,
                        Published:   true,
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
                {
                        CategoryID:  2,
                        Name:        "Laptop",
                        CodeProduct: "LAP-002",
                        Images:      []string{"/images/laptop1.png", "/images/laptop2.png"},
                        Description: "Powerful laptop with high performance",
                        Stock:       30,
                        Price:       1299.99,
                        Published:   true,
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
                {
                        CategoryID:  1,
                        Name:        "Smartwatch",
                        CodeProduct: "SW-003",
                        Images:      []string{"/images/smartwatch1.png", "/images/smartwatch2.png"},
                        Description: "Smartwatch with health monitoring features",
                        Stock:       100,
                        Price:       199.99,
                        Published:   true,
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
                {
                        CategoryID:  3,
                        Name:        "Headphones",
                        CodeProduct: "HP-004",
                        Images:      []string{"/images/headphones1.png", "/images/headphones2.png"},
                        Description: "Wireless headphones with noise cancellation",
                        Stock:       150,
                        Price:       89.99,
                        Published:   false,
                        CreatedAt:   time.Now(),
                        UpdatedAt:   time.Now(),
                },
        }
}</span>

func StockSeed() []Stock <span class="cov0" title="0">{
        return []Stock{
                {
                        ProductID: 1,
                        Type:      "in",
                        Quantity:  10,
                },
                {
                        ProductID: 2,
                        Type:      "in",
                        Quantity:  10,
                },
                {
                        ProductID: 3,
                        Type:      "out",
                        Quantity:  10,
                },
                {
                        ProductID: 4,
                        Type:      "in",
                        Quantity:  10,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package models

import (
        "time"

        "gorm.io/gorm"
)

// Promotion represents the promotion data model
type Promotion struct {
        ID          int             `json:"id" gorm:"primaryKey" swaggerignore:"true"`
        Name        string          `json:"name" gorm:"size:255;not null" binding:"required" example:"Holiday Sale"`
        ProductName JSONB           `json:"product_name" gorm:"type:jsonb;default:'[]'" binding:"omitempty" swaggertype:"array,string" example:"[\"Smartphone\", \"Laptop\"]"`
        Type        JSONB           `json:"type" gorm:"type:jsonb;default:'[]'" binding:"omitempty" swaggertype:"array,string" example:"[\"discount\", \"bundle\"]"`
        Description string          `json:"description" gorm:"size:500" binding:"omitempty" example:"Special holiday discounts"`
        Discount    JSONB           `json:"discount" gorm:"type:jsonb;default:'[]'" binding:"omitempty" swaggertype:"array,string" example:"[{\"value\":10,\"type\":\"percentage\"}]"`
        StartDate   time.Time       `json:"start_date" binding:"required" example:"2024-12-01"`
        EndDate     time.Time       `json:"end_date" binding:"required,gtfield=StartDate" example:"2024-12-31"`
        Quota       int             `json:"quota" gorm:"default:0" example:"100"`
        Status      bool            `json:"status" gorm:"default:false" example:"true"`
        Published   bool            `json:"published" gorm:"default:false" example:"true"`
        CreatedAt   time.Time       `json:"created_at" gorm:"autoCreateTime" swaggerignore:"true"`
        UpdatedAt   time.Time       `json:"updated_at" gorm:"autoUpdateTime" swaggerignore:"true"`
        DeletedAt   *gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty" swaggerignore:"true"`
}

// PromotionSeed returns a list of seed data for promotions
func PromotionSeed() []Promotion <span class="cov0" title="0">{
        return []Promotion{
                {
                        Name:        "Winter Sale",
                        ProductName: JSONB{"Coat", "Gloves"},
                        Type:        JSONB{"discount"},
                        Description: "Get up to 50% off winter essentials",
                        Discount:    JSONB{10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000},
                        StartDate:   time.Date(2024, 12, 1, 0, 0, 0, 0, time.UTC),
                        EndDate:     time.Date(2024, 12, 31, 23, 59, 59, 0, time.UTC),
                        Quota:       200,
                        Status:      true,
                        Published:   true,
                },
                {
                        Name:        "Holiday Discount",
                        ProductName: JSONB{"Smartphone", "Laptop"},
                        Type:        JSONB{"bundle"},
                        Description: "Bundle offer: Buy one smartphone, get a laptop for 30% off",
                        Discount:    JSONB{10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000},
                        StartDate:   time.Date(2024, 12, 10, 0, 0, 0, 0, time.UTC),
                        EndDate:     time.Date(2024, 12, 25, 23, 59, 59, 0, time.UTC),
                        Quota:       150,
                        Status:      true,
                        Published:   true,
                },
                {
                        Name:        "New Year Flash Sale",
                        ProductName: JSONB{"Washing Machine", "Refrigerator"},
                        Type:        JSONB{"discount"},
                        Description: "Up to 40% off on select home appliances",
                        Discount:    JSONB{10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000},
                        StartDate:   time.Date(2024, 12, 26, 0, 0, 0, 0, time.UTC),
                        EndDate:     time.Date(2025, 1, 5, 23, 59, 59, 0, time.UTC),
                        Quota:       100,
                        Status:      true,
                        Published:   true,
                },
                {
                        Name:        "Back to School Sale",
                        ProductName: JSONB{"School Bag", "Stationery"},
                        Type:        JSONB{"bundle"},
                        Description: "Buy a school bag and get a free set of stationery",
                        Discount:    JSONB{10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000},
                        StartDate:   time.Date(2024, 8, 1, 0, 0, 0, 0, time.UTC),
                        EndDate:     time.Date(2024, 8, 15, 23, 59, 59, 0, time.UTC),
                        Quota:       300,
                        Status:      true,
                        Published:   true,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package models

import (
        "dashboard-ecommerce-team2/helper"
        "time"
)

type User struct {
        ID        int       `json:"id" gorm:"primaryKey;autoIncrement" swaggerignore:"true"`
        Name      string    `json:"name" gorm:"size:100;not null" binding:"required" example:"John Doe"`
        Email     string    `json:"email" gorm:"size:100;unique" binding:"required,email" example:"johndoe@example.com"`
        Password  string    `json:"-" gorm:"size:255;not null" binding:"required" swaggerignore:"true"`
        Role      string    `json:"role" gorm:"size:20;check:role IN ('admin','customer', 'staff')" binding:"required,oneof=admin customer staff" example:"admin"`
        CreatedAt time.Time `json:"created_at" gorm:"autoCreateTime" swaggerignore:"true"`
        UpdatedAt time.Time `json:"updated_at" gorm:"autoUpdateTime" swaggerignore:"true"`
}

type LoginRequest struct {
        Email    string `json:"email" binding:"required,email" example:"johndoe@example.com"`
        Password string `json:"password" binding:"required,min=8" example:"password123"`
}

type RegisterRequest struct {
        Name     string `json:"name" binding:"required" example:"John Doe"`
        Email    string `json:"email" binding:"required,email" example:"johndoe@example.com"`
        Password string `json:"password" binding:"required,min=8" example:"password123"`
}

type CheckEmailRequest struct {
        Email string `json:"email" binding:"required,email" example:"johndoe@example"`
}

func UserSeed() []User <span class="cov0" title="0">{
        return []User{
                {
                        Name:     "Admin User",
                        Email:    "admin@example.com",
                        Password: helper.HashPassword("adminpassword"),
                        Role:     "admin",
                },
                {
                        Name:     "Staff User 1",
                        Email:    "staff1@example.com",
                        Password: helper.HashPassword("staffpassword1"),
                        Role:     "staff",
                },
                {
                        Name:     "Staff User 2",
                        Email:    "staff2@example.com",
                        Password: helper.HashPassword("staffpassword2"),
                        Role:     "staff",
                },
                {
                        Name:     "User 1",
                        Email:    "user1@example.com",
                        Password: helper.HashPassword("userpassword1"),
                        Role:     "customer",
                },
                {
                        Name:     "User 2",
                        Email:    "user2@example.com",
                        Password: helper.HashPassword("userpassword2"),
                        Role:     "customer",
                },
                {
                        Name:     "User 3",
                        Email:    "user3@example.com",
                        Password: helper.HashPassword("userpassword3"),
                        Role:     "customer",
                },
                {
                        Name:     "User 4",
                        Email:    "user4@example.com",
                        Password: helper.HashPassword("userpassword4"),
                        Role:     "customer",
                },
                {
                        Name:     "User 5",
                        Email:    "user5@example.com",
                        Password: helper.HashPassword("userpassword5"),
                        Role:     "customer",
                },
                {
                        Name:     "User 6",
                        Email:    "user6@example.com",
                        Password: helper.HashPassword("userpassword6"),
                        Role:     "customer",
                },
                {
                        Name:     "User 7",
                        Email:    "user7@example.com",
                        Password: helper.HashPassword("userpassword7"),
                        Role:     "customer",
                },
                {
                        Name:     "User 8",
                        Email:    "user8@example.com",
                        Password: helper.HashPassword("userpassword8"),
                        Role:     "customer",
                },
                {
                        Name:     "User 9",
                        Email:    "user9@example.com",
                        Password: helper.HashPassword("userpassword9"),
                        Role:     "customer",
                },
                {
                        Name:     "User 10",
                        Email:    "user10@example.com",
                        Password: helper.HashPassword("userpassword10"),
                        Role:     "customer",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package categoryrepository

import (
        "dashboard-ecommerce-team2/models"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type CategoryRepository interface {
        Create(categoryInput models.Category) error
        Update(categoryInput models.Category) error
        Delete(id int) error
        GetByID(id int) (*models.Category, error)
        GetAll(page, limit int) ([]models.Category, int64, error)
}

type categoryRepository struct {
        DB  *gorm.DB
        Log *zap.Logger
}

// Create implements CategoryRepository.
func (c *categoryRepository) Create(categoryInput models.Category) error <span class="cov0" title="0">{
        // var existingCategory models.Category
        // if err := c.DB.Where("name = ?", categoryInput.Name).First(&amp;existingCategory).Error; err == nil {
        //         log.Printf("Category with name '%s' already exists", categoryInput.Name)
        //         return errors.New("category already exists")
        // }

        c.Log.Info("Creating a new category", zap.String("name", categoryInput.Name), zap.String("icon", categoryInput.Icon))
        if err := c.DB.Create(&amp;categoryInput).Error; err != nil </span><span class="cov0" title="0">{
                c.Log.Error("Failed to create category", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete implements CategoryRepository.
func (c *categoryRepository) Delete(id int) error <span class="cov0" title="0">{
        c.Log.Info("Deleting category", zap.Int("id", id))
        if err := c.DB.Delete(&amp;models.Category{}, id).Error; err != nil </span><span class="cov0" title="0">{
                c.Log.Error("Failed to delete category", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetAll implements CategoryRepository.
func (c *categoryRepository) GetAll(page, limit int) ([]models.Category, int64, error) <span class="cov0" title="0">{
        c.Log.Info("Fetching all categories with pagination", zap.Int("page", page), zap.Int("limit", limit))

        var categories []models.Category
        var totalItems int64

        if err := c.DB.Model(&amp;models.Category{}).Count(&amp;totalItems).Error; err != nil </span><span class="cov0" title="0">{
                c.Log.Error("Failed to count categories", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * limit

        if err := c.DB.Limit(limit).Offset(offset).Find(&amp;categories).Error; err != nil </span><span class="cov0" title="0">{
                c.Log.Error("Failed to fetch paginated categories", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return categories, totalItems, nil</span>
}

// GetByID implements CategoryRepository.
func (c *categoryRepository) GetByID(id int) (*models.Category, error) <span class="cov0" title="0">{
        c.Log.Info("Fetching category by ID", zap.Int("id", id))
        var category models.Category
        if err := c.DB.First(&amp;category, id).Error; err != nil </span><span class="cov0" title="0">{
                c.Log.Error("Failed to fetch category by ID", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;category, nil</span>
}

// Update implements CategoryRepository.
func (c *categoryRepository) Update(categoryInput models.Category) error <span class="cov0" title="0">{
        c.Log.Info("Updating category", zap.Int("id", categoryInput.ID))
        if err := c.DB.Model(&amp;models.Category{}).Where("id = ?", categoryInput.ID).Updates(categoryInput).Error; err != nil </span><span class="cov0" title="0">{
                c.Log.Error("Failed to update category", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func NewCategoryRepository(db *gorm.DB, log *zap.Logger) CategoryRepository <span class="cov8" title="1">{
        return &amp;categoryRepository{DB: db, Log: log}
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package orderrepository

import (
        "dashboard-ecommerce-team2/models"
        "math"
        "time"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type OrderRepository interface {
        UpdateStatus(id int, status string) error
        GetByID(id int) (*models.Order, error)
        GetAll(page, limit int) ([]models.Order, int64, error)
        CountOrder() (int, error)
        CountTotalPriceOrder() (float64, error)
        GetEarningEachMonth() ([]models.Revenue, error)
        GetDetail(id int) (*models.Order, []models.OrderItem, error)
        DeleteOrder(id int) error
}

type orderRepository struct {
        DB  *gorm.DB
        Log *zap.Logger
}

// GetEarningEachMonth implements OrderRepository.
func (o *orderRepository) GetEarningEachMonth() ([]models.Revenue, error) <span class="cov0" title="0">{
        var revenues []models.Revenue
        currentYear := time.Now().Year()

        // Perform the query to calculate total earnings for each month of the current year
        err := o.DB.Table("(VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10), (11), (12)) AS months(month)").
                Select("TO_CHAR(DATE_TRUNC('month', TO_DATE(CAST(month AS TEXT), 'MM')), 'Month') AS month, COALESCE(SUM(total_amount), 0) AS total_earning").
                Joins(`LEFT JOIN orders ON 
                                EXTRACT(MONTH FROM orders.created_at) = months.month 
                                AND EXTRACT(YEAR FROM orders.created_at) = ? 
                                AND orders.status = ?`, currentYear, "completed").
                Group("months.month").
                Order("months.month ASC").
                Scan(&amp;revenues).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, revenue := range revenues </span><span class="cov0" title="0">{
                totalEarning := revenue.TotalEarning * ((100 - 10) / 100)
                revenue.TotalEarning = math.Round(totalEarning*100) / 100
        }</span>

        <span class="cov0" title="0">return revenues, nil</span>
}

// CountTotalPriceOrder implements OrderRepository.
func (o *orderRepository) CountTotalPriceOrder() (float64, error) <span class="cov0" title="0">{
        var totalPrice float64
        err := o.DB.Table("orders").
                Select("COALESCE(SUM(total_amount), 0)").
                Where("status = ? AND EXTRACT(MONTH FROM created_at) = ? AND EXTRACT(YEAR FROM created_at) = ?", "completed", time.Now().Month(), time.Now().Year()).
                Scan(&amp;totalPrice).Error

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">newTotal := math.Round(totalPrice*100) / 100
        return newTotal, nil</span>
}

// CountOrder implements OrderRepository.
func (o *orderRepository) CountOrder() (int, error) <span class="cov0" title="0">{
        var count int64
        err := o.DB.Model(&amp;models.Order{}).
                Where("status = ? AND EXTRACT(MONTH FROM created_at) = ? AND EXTRACT(YEAR FROM created_at) = ?", "completed", time.Now().Month(), time.Now().Year()).
                Count(&amp;count).Error

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return int(count), nil</span>
}

// GetAll implements OrderRepository.
func (o *orderRepository) GetAll(page, limit int) ([]models.Order, int64, error) <span class="cov0" title="0">{
        var orders []models.Order
        var totalItems int64

        offset := (page - 1) * limit

        if err := o.DB.Model(&amp;models.Order{}).Count(&amp;totalItems).Error; err != nil </span><span class="cov0" title="0">{
                o.Log.Error("Failed to count orders", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">if err := o.DB.Limit(limit).Offset(offset).Find(&amp;orders).Error; err != nil </span><span class="cov0" title="0">{
                o.Log.Error("Failed to retrieve paginated orders", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return orders, totalItems, nil</span>
}

// GetByID implements OrderRepository.
func (o *orderRepository) GetByID(id int) (*models.Order, error) <span class="cov0" title="0">{
        order := models.Order{}
        if err := o.DB.First(&amp;order, id).Error; err != nil </span><span class="cov0" title="0">{
                o.Log.Error("Failed to find order", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;order, nil</span>
}

// UpdateStatus implements OrderRepository.
func (o *orderRepository) UpdateStatus(id int, status string) error <span class="cov0" title="0">{
        order := models.Order{}
        if err := o.DB.First(&amp;order, id).Error; err != nil </span><span class="cov0" title="0">{
                o.Log.Error("Failed to find order", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">order.Status = status
        return o.DB.Save(&amp;order).Error</span>
}

func (o *orderRepository) DeleteOrder(id int) error <span class="cov0" title="0">{
        var orderItems []models.OrderItem
        if err := o.DB.Where("order_id = ?", id).Delete(&amp;orderItems).Error; err != nil </span><span class="cov0" title="0">{
                o.Log.Error("Failed to delete order items", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">if err := o.DB.Delete(&amp;models.Order{}, id).Error; err != nil </span><span class="cov0" title="0">{
                o.Log.Error("Failed to delete order", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o *orderRepository) GetDetail(id int) (*models.Order, []models.OrderItem, error) <span class="cov0" title="0">{
        var order models.Order
        if err := o.DB.First(&amp;order, id).Error; err != nil </span><span class="cov0" title="0">{
                o.Log.Error("Failed to find order", zap.Error(err))
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">var orderItems []models.OrderItem
        if err := o.DB.Where("order_id = ?", id).Find(&amp;orderItems).Error; err != nil </span><span class="cov0" title="0">{
                o.Log.Error("Failed to retrieve order items", zap.Error(err))
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return &amp;order, orderItems, nil</span>
}

func NewOrderRepository(db *gorm.DB, log *zap.Logger) OrderRepository <span class="cov8" title="1">{
        return &amp;orderRepository{DB: db, Log: log}
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package orderrepository

import (
        "dashboard-ecommerce-team2/models"

        "github.com/stretchr/testify/mock"
)

type OrderRepositoryMock struct {
        mock.Mock
}

// GetAll implements OrderRepository.
func (o *OrderRepositoryMock) GetAll() ([]models.Order, error) <span class="cov0" title="0">{
        panic("unimplemented")</span>
}

// GetByID implements OrderRepositoryMock.
func (o *OrderRepositoryMock) GetByID(id int) (*models.Order, error) <span class="cov0" title="0">{
        panic("unimplemented")</span>
}

// UpdateStatus implements OrderRepositoryMock.
func (o *OrderRepositoryMock) UpdateStatus(id int, status string) error <span class="cov0" title="0">{
        panic("unimplemented")</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package productrepository

import (
        "dashboard-ecommerce-team2/models"
        "encoding/json"
        "fmt"
        "time"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type ProductRepository interface {
        Create(productInput *models.Product) error
        Update(id int, productInput models.Product) (*models.Product, error)
        Delete(id int) error
        GetByID(id int) (*models.ProductID, error)
        GetAll(page, pageSize int) ([]*models.ProductWithCategory, int64, error)
        CountProduct() (int, error)
        CountEachProduct() ([]models.BestProduct, error)
}

type productRepository struct {
        DB  *gorm.DB
        Log *zap.Logger
}

func NewProductRepository(db *gorm.DB, log *zap.Logger) ProductRepository <span class="cov8" title="1">{
        return &amp;productRepository{DB: db, Log: log}
}</span>

// CountEachProduct implements ProductRepository.
func (p *productRepository) CountEachProduct() ([]models.BestProduct, error) <span class="cov0" title="0">{
        type ProductCount struct {
                ProductID uint   `gorm:"column:product_id"`
                Name      string `gorm:"column:name"`
                Total     int    `gorm:"column:total"`
        }

        var productCounts []ProductCount
        var bestProducts []models.BestProduct

        // Perform the query to count products grouped by product ID
        err := p.DB.Table("order_items").
                Select("order_items.product_id, products.name, COALESCE(COUNT(order_items.product_id), 0) AS total").
                Joins("JOIN orders ON orders.id = order_items.order_id AND orders.status = ?", "completed").
                Joins("JOIN products ON products.id = order_items.product_id").
                Group("order_items.product_id, products.name").
                Order("total DESC").
                Scan(&amp;productCounts).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Map the query results to the []models.BestProduct slice
        <span class="cov0" title="0">for _, pc := range productCounts </span><span class="cov0" title="0">{
                bestProducts = append(bestProducts, models.BestProduct{
                        ProductID: int(pc.ProductID),
                        Name:      pc.Name,
                        Total:     pc.Total,
                })
        }</span>

        <span class="cov0" title="0">return bestProducts, nil</span>
}

// CountProduct implements ProductRepository.
func (p *productRepository) CountProduct() (int, error) <span class="cov0" title="0">{
        var count int64

        // Query to count distinct products in completed orders
        err := p.DB.Table("order_items").
                Joins("JOIN orders ON orders.id = order_items.order_id AND orders.status = ?", "completed").
                Where("EXTRACT(MONTH FROM orders.created_at) = ? AND EXTRACT(YEAR FROM orders.created_at) = ?", time.Now().Month(), time.Now().Year()).
                Select("COALESCE(SUM(order_items.quantity),0)").
                Scan(&amp;count).Error

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return int(count), nil</span>
}

// Create implements ProductRepository.
func (p *productRepository) Create(productInput *models.Product) error <span class="cov0" title="0">{

        p.Log.Info("Creating product", zap.Any("input", productInput))
        err := p.DB.Create(productInput).Error
        if err != nil </span><span class="cov0" title="0">{
                p.Log.Error("repository: Error creating product", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete implements ProductRepository.
func (p *productRepository) Delete(id int) error <span class="cov0" title="0">{
        var product models.Product

        err := p.DB.First(&amp;product, id).Error
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "record not found" </span><span class="cov0" title="0">{
                        return fmt.Errorf("product not found")
                }</span>
                <span class="cov0" title="0">p.Log.Error("Failed to fetch product for deletion", zap.Error(err))
                return err</span>
        }

        <span class="cov0" title="0">err = p.DB.Delete(&amp;product).Error
        if err != nil </span><span class="cov0" title="0">{
                p.Log.Error("Failed to delete product", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetAll implements ProductRepository.
func (p *productRepository) GetAll(page, pageSize int) ([]*models.ProductWithCategory, int64, error) <span class="cov0" title="0">{
        // var products []*models.Product
        var productsWithCategory []*models.ProductWithCategory
        var totalItems int64

        offset := (page - 1) * pageSize

        // Menghitung total items
        err := p.DB.Model(&amp;models.Product{}).Count(&amp;totalItems).Error
        if err != nil </span><span class="cov0" title="0">{
                p.Log.Error("Failed to count total products", zap.Error(err))
                return nil, 0, err
        }</span>

        // Mengambil produk dengan pagination
        <span class="cov0" title="0">err = p.DB.Table("products").
                Select(`products.id, 
            categories.name AS category_name, 
            products.name, 
            products.code_product, 
            products.images, 
            products.description, 
            products.stock, 
            products.price, 
            products.published`).
                Joins("JOIN categories ON categories.id = products.category_id").
                Offset(offset).
                Limit(pageSize).
                Find(&amp;productsWithCategory).Error

        if err != nil </span><span class="cov0" title="0">{
                p.Log.Error("Failed to fetch products", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return productsWithCategory, totalItems, nil</span>
}

// GetByID implements ProductRepository.
func (p *productRepository) GetByID(id int) (*models.ProductID, error) <span class="cov0" title="0">{
        var productID models.ProductID
        var variantJSON []byte

        err := p.DB.Table("products").
                Select(`
                        products.id, 
                        products.category_id,
                        categories.name AS category_name, 
                        CASE WHEN categories.variant = '{}' THEN NULL ELSE categories.variant END AS variant,
                        products.name, 
                        products.code_product, 
                        products.images, 
                        products.description, 
                        products.stock, 
                        products.price, 
                        products.published
                `).
                Joins("JOIN categories ON categories.id = products.category_id").
                Where("products.id = ?", id).
                First(&amp;productID).Error

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "record not found" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("product not found")
                }</span>
                <span class="cov0" title="0">p.Log.Error("Failed to fetch product by ID", zap.Error(err))
                return nil, err</span>
        }
        <span class="cov0" title="0">if len(variantJSON) &gt; 0 </span><span class="cov0" title="0">{
                if err := json.Unmarshal(variantJSON, &amp;productID.Variant); err != nil </span><span class="cov0" title="0">{
                        p.Log.Error("Repository: failed to unmarshal variant JSON", zap.Error(err))
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return &amp;productID, nil</span>
}

// Update implements ProductRepository.
func (p *productRepository) Update(id int, productInput models.Product) (*models.Product, error) <span class="cov0" title="0">{
        p.Log.Info("Updated product", zap.Any("input", productInput))

        var product models.Product
        err := p.DB.Model(&amp;models.Product{}).Where("id = ?", id).Updates(productInput).First(&amp;product).Error
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "record not found" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("product not found")
                }</span>
                <span class="cov0" title="0">p.Log.Error("repository: update failed", zap.Error(err))
                return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;product, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package productrepository

import (
        "dashboard-ecommerce-team2/models"

        "github.com/stretchr/testify/mock"
)

type ProductRepositoryMock struct {
        mock.Mock
}

func (p *ProductRepositoryMock) Create(productInput models.Product) error <span class="cov0" title="0">{
        panic("unimplemented")</span>
}

// Delete implements ProductRepositoryMock.
func (p *ProductRepositoryMock) Delete(id int) error <span class="cov0" title="0">{
        panic("unimplemented")</span>
}

// GetAll implements ProductRepositoryMock.
func (p *ProductRepositoryMock) GetAll() ([]models.Product, error) <span class="cov0" title="0">{
        panic("unimplemented")</span>
}

// GetByID implements ProductRepositoryMock.
func (p *ProductRepositoryMock) GetByID(id int) (*models.Product, error) <span class="cov0" title="0">{
        panic("unimplemented")</span>
}

// Update implements ProductRepository.
func (p *ProductRepositoryMock) Update(productInput models.Product) error <span class="cov0" title="0">{
        panic("unimplemented")</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package promotionrepository

import (
        "dashboard-ecommerce-team2/models"
        "errors"
        "fmt"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type PromotionRepository interface {
        Create(promotionInput *models.Promotion) error
        Update(promotionInput *models.Promotion) error
        Delete(id int) error
        GetAll() ([]models.Promotion, error)
        GetByID(id int) (*models.Promotion, error)
}

type promotionRepository struct {
        DB  *gorm.DB
        Log *zap.Logger
}

// Create implements PromotionRepository.
func (p *promotionRepository) Create(promotionInput *models.Promotion) error <span class="cov0" title="0">{
        err := p.DB.Create(promotionInput).Error
        if err != nil </span><span class="cov0" title="0">{
                p.Log.Error("Error from repo creating promotions:", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete implements PromotionRepository.
func (p *promotionRepository) Delete(id int) error <span class="cov0" title="0">{
        var promotion models.Promotion
        err := p.DB.First(&amp;promotion, id).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        p.Log.Warn("Promotion ID not found:", zap.Int("ID", id))
                        return fmt.Errorf("Promotion with ID %d not found", id)
                }</span>

                <span class="cov0" title="0">p.Log.Error("Error finding promotion before delete:", zap.Error(err))
                return err</span>
        }

        // Hapus promotion jika ditemukan
        <span class="cov0" title="0">err = p.DB.Delete(&amp;models.Promotion{}, id).Error
        if err != nil </span><span class="cov0" title="0">{
                p.Log.Error("Error deleting promotion:", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetAll implements PromotionRepository.
func (p *promotionRepository) GetAll() ([]models.Promotion, error) <span class="cov0" title="0">{
        promotions := []models.Promotion{}
        if err := p.DB.Find(&amp;promotions).Error; err != nil </span><span class="cov0" title="0">{
                p.Log.Error("Error get all promotion:", zap.Error(err))
                return []models.Promotion{}, err
        }</span>

        <span class="cov0" title="0">return promotions, nil</span>
}

// GetByID implements PromotionRepository.
func (p *promotionRepository) GetByID(id int) (*models.Promotion, error) <span class="cov0" title="0">{
        var promotion models.Promotion

        // Mencari promotion berdasarkan ID
        err := p.DB.First(&amp;promotion, id).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        p.Log.Warn("Promotion ID not found", zap.Int("ID", id))
                        return nil, fmt.Errorf("promotion with ID %d not found", id)
                }</span>

                <span class="cov0" title="0">p.Log.Error("Error retrieving promotion by ID", zap.Int("ID", id), zap.Error(err))
                return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;promotion, nil</span>
}

// Update implements PromotionRepository.
func (p *promotionRepository) Update(promotionInput *models.Promotion) error <span class="cov0" title="0">{
        err := p.DB.Save(promotionInput).Error
        if err != nil </span><span class="cov0" title="0">{
                p.Log.Error("Error from repo updating promption:", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func NewPromotionRepository(db *gorm.DB, log *zap.Logger) PromotionRepository <span class="cov8" title="1">{
        return &amp;promotionRepository{DB: db, Log: log}
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package repository

import (
        bannerrepository "dashboard-ecommerce-team2/repository/banner"
        categoryrepository "dashboard-ecommerce-team2/repository/category"
        orderrepository "dashboard-ecommerce-team2/repository/order"
        productrepository "dashboard-ecommerce-team2/repository/product"
        promotionrepository "dashboard-ecommerce-team2/repository/promotion"
        stockrepository "dashboard-ecommerce-team2/repository/stock"
        userrepository "dashboard-ecommerce-team2/repository/user"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type Repository struct {
        Banner    bannerrepository.BannerRepository
        Category  categoryrepository.CategoryRepository
        Order     orderrepository.OrderRepository
        Product   productrepository.ProductRepository
        Promotion promotionrepository.PromotionRepository
        Stock     stockrepository.StockRepository
        User      userrepository.UserRepository
}

func NewRepository(db *gorm.DB, log *zap.Logger) Repository <span class="cov8" title="1">{
        return Repository{
                Banner:    bannerrepository.NewBannerRepository(db, log),
                Category:  categoryrepository.NewCategoryRepository(db, log),
                Order:     orderrepository.NewOrderRepository(db, log),
                Product:   productrepository.NewProductRepository(db, log),
                Promotion: promotionrepository.NewPromotionRepository(db, log),
                Stock:     stockrepository.NewStockRepository(db, log),
                User:      userrepository.NewUserRepository(db, log),
        }
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package stockrepository

import (
        "dashboard-ecommerce-team2/models"
        "encoding/json"
        "fmt"
        "time"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type StockRepository interface {
        Update(stockHistory *models.StockRequest) error
        Delete(id int) error
        GetByID(id int) (*models.StockResponse, error)
}

type stockRepository struct {
        DB  *gorm.DB
        Log *zap.Logger
}

// Delete implements StockRepository.
func (s *stockRepository) Delete(id int) error <span class="cov0" title="0">{
        var stockHistory models.Stock

        err := s.DB.First(&amp;stockHistory, id).Error
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "record not found" </span><span class="cov0" title="0">{
                        return fmt.Errorf("history not found")
                }</span>
                <span class="cov0" title="0">s.Log.Error("Failed to fetch history for deletion", zap.Error(err))
                return err</span>
        }

        <span class="cov0" title="0">err = s.DB.Delete(&amp;stockHistory).Error
        if err != nil </span><span class="cov0" title="0">{
                s.Log.Error("Failed to delete history", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetByID implements StockRepository.
func (s *stockRepository) GetByID(id int) (*models.StockResponse, error) <span class="cov0" title="0">{
        var stockHistory models.StockResponse
        var variantJSON []byte

        err := s.DB.Table("stocks").
                Select("stocks.id, stocks.product_id, stocks.type, stocks.quantity, stocks.created_at, stocks.updated_at, products.name as product_name, CASE WHEN categories.variant = '{}' THEN NULL ELSE categories.variant END AS variant").
                Joins("JOIN products ON products.id = stocks.product_id").
                Joins("JOIN categories ON categories.id = products.category_id").
                Where("stocks.id = ?", id).
                First(&amp;stockHistory).Error

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "record not found" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("product not found")
                }</span>
                <span class="cov0" title="0">s.Log.Error("Failed to fetch product by ID", zap.Error(err))
                return nil, err</span>
        }
        <span class="cov0" title="0">if len(variantJSON) &gt; 0 </span><span class="cov0" title="0">{
                if err := json.Unmarshal(variantJSON, &amp;stockHistory.Variant); err != nil </span><span class="cov0" title="0">{
                        s.Log.Error("Repository: failed to unmarshal variant JSON", zap.Error(err))
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return &amp;stockHistory, nil</span>
}

// UpdateStock implements StockRepository.
func (s *stockRepository) Update(stockHistory *models.StockRequest) error <span class="cov0" title="0">{
        tx := s.DB.Begin()

        var currentStock int
        if err := tx.Table("products").
                Select("stock").
                Where("id = ?", stockHistory.ProductID).
                Scan(&amp;currentStock).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("failed to fetch current stock: %w", err)
        }</span>

        <span class="cov0" title="0">newStock := currentStock
        if stockHistory.Type == "in" </span><span class="cov0" title="0">{
                newStock += stockHistory.Quantity
        }</span> else<span class="cov0" title="0"> if stockHistory.Type == "out" </span><span class="cov0" title="0">{
                if stockHistory.Quantity &gt; currentStock </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return fmt.Errorf("insufficient stock")
                }</span>
                <span class="cov0" title="0">newStock -= stockHistory.Quantity</span>
        } else<span class="cov0" title="0"> {
                tx.Rollback()
                return fmt.Errorf("invalid stock type")
        }</span>

        <span class="cov0" title="0">if err := tx.Table("products").
                Where("id = ?", stockHistory.ProductID).
                Updates(map[string]interface{}{
                        "stock":      newStock,
                        "updated_at": time.Now(),
                }).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("failed to update product stock: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Table("stocks").Create(stockHistory).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return fmt.Errorf("failed to create stock history: %w", err)
        }</span>

        <span class="cov0" title="0">tx.Commit()
        return nil</span>
}

func NewStockRepository(db *gorm.DB, log *zap.Logger) StockRepository <span class="cov8" title="1">{
        return &amp;stockRepository{DB: db, Log: log}
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package userrepository

import (
        "dashboard-ecommerce-team2/models"
        "time"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type UserRepository interface {
        Create(userInput models.User) error
        GetByEmail(email string) (*models.User, error)
        UpdatePassword(resetPasswordInput models.LoginRequest) error
        CountCustomer() (int, error)
}

type userRepository struct {
        DB  *gorm.DB
        Log *zap.Logger
}

// Create implements UserRepository.
func (u *userRepository) Create(userInput models.User) error <span class="cov0" title="0">{
        return u.DB.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                if err := tx.Create(&amp;userInput).Error; err != nil </span><span class="cov0" title="0">{
                        u.Log.Error("Failed to create user", zap.Error(err))
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
}

// GetByEmail implements UserRepository.
func (u *userRepository) GetByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        var user models.User
        err := u.DB.Where("email = ?", email).First(&amp;user).Error
        return &amp;user, err
}</span>

// UpdatePassword implements UserRepository.
func (u *userRepository) UpdatePassword(resetPasswordInput models.LoginRequest) error <span class="cov0" title="0">{
        return u.DB.Model(&amp;models.User{}).Where("email =?", resetPasswordInput.Email).Update("password", resetPasswordInput.Password).Error
}</span>

// CountCustomer implements UserRepository.
func (u *userRepository) CountCustomer() (int, error) <span class="cov0" title="0">{
        var count int64
        err := u.DB.Model(&amp;models.User{}).
                Where("role = ?", "customer").
                Where("EXTRACT(MONTH FROM created_at) = ? AND EXTRACT(YEAR FROM created_at) = ?", time.Now().Month(), time.Now().Year()).
                Count(&amp;count).Error

        return int(count), err
}</span>

func NewUserRepository(db *gorm.DB, log *zap.Logger) UserRepository <span class="cov8" title="1">{
        return &amp;userRepository{DB: db, Log: log}
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package userrepository

import (
        "dashboard-ecommerce-team2/models"

        "github.com/stretchr/testify/mock"
)

type MockUserRepository struct {
        mock.Mock
        UserRepo UserRepository
}

func (m *MockUserRepository) Create(userInput models.User) error <span class="cov8" title="1">{
        args := m.Called(userInput)
        return args.Error(0)
}</span>

// GetByEmail mocks the GetByEmail method
func (m *MockUserRepository) GetByEmail(email string) (*models.User, error) <span class="cov8" title="1">{
        args := m.Called(email)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*models.User), args.Error(1)</span>
}

// UpdatePassword mocks the UpdatePassword method
func (m *MockUserRepository) UpdatePassword(resetPasswordInput models.LoginRequest) error <span class="cov8" title="1">{
        args := m.Called(resetPasswordInput)
        return args.Error(0)
}</span>

func (m *MockUserRepository) CountCustomer() (int, error) <span class="cov0" title="0">{
        args := m.Called()
        return args.Int(0), args.Error(1)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package routes

import (
        "dashboard-ecommerce-team2/infra"

        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

func NewRoutes(ctx infra.ServiceContext) *gin.Engine <span class="cov0" title="0">{

        r := gin.Default()

        r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        authMiddleware := ctx.Middleware.Authentication()
        adminMiddleware := ctx.Middleware.RoleAuthorization("admin")

        productRoutes := r.Group("/products", authMiddleware)
        </span><span class="cov0" title="0">{
                productRoutes.POST("/", ctx.Ctl.Product.CreateProductController)
                productRoutes.GET("/", ctx.Ctl.Product.GetAllProductsController)
                productRoutes.GET("/:id", ctx.Ctl.Product.GetProductByIDController)
                productRoutes.DELETE("/:id", adminMiddleware, ctx.Ctl.Product.DeleteProductController)
                productRoutes.PUT("/:id", ctx.Ctl.Product.UpdateProductController)
        }</span>
        <span class="cov0" title="0">stockRoutes := r.Group("/stock", authMiddleware)
        </span><span class="cov0" title="0">{
                stockRoutes.GET("/:id", ctx.Ctl.Stock.GetProductStockDetailController)
                stockRoutes.DELETE("/:id", adminMiddleware, ctx.Ctl.Stock.DeleteProductStockController)
                stockRoutes.PUT("/", ctx.Ctl.Stock.UpdateProductStockController)
        }</span>

        <span class="cov0" title="0">orderRoutes := r.Group("/orders", authMiddleware)
        </span><span class="cov0" title="0">{
                orderRoutes.GET("/", ctx.Ctl.Order.GetAllOrdersController)
                orderRoutes.GET("/:id", ctx.Ctl.Order.GetOrderByIDController)
                orderRoutes.PUT("/update/:id", ctx.Ctl.Order.UpdateOrderStatusController)
                orderRoutes.DELETE("/:id", adminMiddleware, ctx.Ctl.Order.DeleteOrderController)
                orderRoutes.GET("/detail/:id", ctx.Ctl.Order.GetOrderDetailController)
        }</span>

        <span class="cov0" title="0">categoryRoutes := r.Group("/category", adminMiddleware)
        </span><span class="cov0" title="0">{
                categoryRoutes.POST("/create", ctx.Ctl.Category.CreateCatergoryController)
                categoryRoutes.GET("/list", ctx.Ctl.Category.GetAllCategoriesController)
                categoryRoutes.GET("/:id", ctx.Ctl.Category.GetCategoryByIDController)
                categoryRoutes.PUT("/update/:id", ctx.Ctl.Category.UpdateCategoryController)
                categoryRoutes.DELETE("/:id", adminMiddleware, ctx.Ctl.Category.DeleteCategoryController)
        }</span>

        <span class="cov0" title="0">authRoutes(r, ctx)
        dashboardRoutes(r, ctx)
        bannerRoutes(r, ctx)
        promotionRoutes(r, ctx)
        return r</span>
}

func bannerRoutes(r *gin.Engine, ctx infra.ServiceContext) <span class="cov0" title="0">{
        banner := r.Group("/api", ctx.Middleware.Authentication())
        banner.GET("/banner", ctx.Ctl.Banner.GetBannerByIDController)
        banner.PUT("/banner", ctx.Ctl.Banner.UpdateBannerController)
        banner.POST("/create-banner", ctx.Ctl.Banner.CreateBannerController)
        banner.DELETE("/banner", ctx.Middleware.RoleAuthorization("admin"), ctx.Ctl.Banner.DeleteBannerController)
}</span>

func promotionRoutes(r *gin.Engine, ctx infra.ServiceContext) <span class="cov0" title="0">{
        promotion := r.Group("/api", ctx.Middleware.Authentication())
        promotion.GET("/list-promotion", ctx.Ctl.Promotion.GetAllPromotionsController)
        promotion.GET("/promotion", ctx.Ctl.Promotion.GetByIdPromotionsController)
        promotion.PUT("/promotion", ctx.Ctl.Promotion.UpdatePromotionController)
        promotion.POST("/create-promotion", ctx.Ctl.Promotion.CreatePromotionController)
        promotion.DELETE("/promotion", ctx.Middleware.RoleAuthorization("admin"), ctx.Ctl.Promotion.DeletePromotionController)
}</span>

func authRoutes(r *gin.Engine, ctx infra.ServiceContext) <span class="cov0" title="0">{
        authGroup := r.Group("/auth")
        authGroup.POST("/login", ctx.Ctl.User.LoginController)
        authGroup.POST("/check-email", ctx.Ctl.User.CheckEmailUserController)
        authGroup.POST("/register", ctx.Ctl.User.CreateUserController)
        authGroup.PATCH("/reset-password", ctx.Ctl.User.ResetUserPasswordController)
}</span>

func dashboardRoutes(r *gin.Engine, ctx infra.ServiceContext) <span class="cov0" title="0">{
        dashboardGroup := r.Group("/dashboard")
        dashboardGroup.Use(ctx.Middleware.Authentication())
        </span><span class="cov0" title="0">{
                dashboardGroup.GET("/summary", ctx.Ctl.Dashboard.GetSummaryController)
                dashboardGroup.GET("/current-month-earning", ctx.Ctl.Dashboard.CurrentMonthEarningController)
                dashboardGroup.GET("/revenue-chart", ctx.Ctl.Dashboard.RenevueChartController)
                dashboardGroup.GET("/best-item-list", ctx.Ctl.Dashboard.GetBestProductListController)
        }</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package categoryservice

import (
        "dashboard-ecommerce-team2/models"
        "dashboard-ecommerce-team2/repository"

        "go.uber.org/zap"
)

type CategoryService interface {
        CreateCatergory(categoryInput models.Category) error
        GetAllCategories(page, limit int) ([]models.Category, int64, error)
        GetCategoryByID(id int) (*models.Category, error)
        UpdateCategory(categoryInput models.Category) error
        DeleteCategory(id int) error
}

type categoryService struct {
        Repo repository.Repository
        Log  *zap.Logger
}

// CreateCatergory implements CategoryService.
func (c *categoryService) CreateCatergory(categoryInput models.Category) error <span class="cov0" title="0">{
        c.Log.Info("Service: Creating category", zap.String("name", categoryInput.Name))
        if err := c.Repo.Category.Create(categoryInput); err != nil </span><span class="cov0" title="0">{
                c.Log.Error("Service: Failed to create category", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteCategory implements CategoryService.
func (c *categoryService) DeleteCategory(id int) error <span class="cov0" title="0">{
        c.Log.Info("Service: Deleting category", zap.Int("id", id))
        if err := c.Repo.Category.Delete(id); err != nil </span><span class="cov0" title="0">{
                c.Log.Error("Service: Failed to delete category", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetAllCategories implements CategoryService.
func (c *categoryService) GetAllCategories(page, limit int) ([]models.Category, int64, error) <span class="cov0" title="0">{
        c.Log.Info("Service: Fetching all categories", zap.Int("page", page), zap.Int("limit", limit))
        categories, totalItems, err := c.Repo.Category.GetAll(page, limit)
        if err != nil </span><span class="cov0" title="0">{
                c.Log.Error("Service: Failed to fetch categories", zap.Error(err))
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">return categories, totalItems, nil</span>
}

// GetCategoryByID implements CategoryService.
func (c *categoryService) GetCategoryByID(id int) (*models.Category, error) <span class="cov0" title="0">{
        c.Log.Info("Service: Fetching category by ID", zap.Int("id", id))
        category, err := c.Repo.Category.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                c.Log.Error("Service: Failed to fetch category by ID", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">return category, nil</span>
}

// UpdateCategory implements CategoryService.
func (c *categoryService) UpdateCategory(categoryInput models.Category) error <span class="cov0" title="0">{
        c.Log.Info("Service: Updating category", zap.Int("id", categoryInput.ID))
        if err := c.Repo.Category.Update(categoryInput); err != nil </span><span class="cov0" title="0">{
                c.Log.Error("Service: Failed to update category", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func NewCategoryService(repo repository.Repository, log *zap.Logger) CategoryService <span class="cov8" title="1">{
        return &amp;categoryService{Repo: repo, Log: log}
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package dashboardservice

import (
        "bytes"
        "dashboard-ecommerce-team2/models"
        "dashboard-ecommerce-team2/repository"
        "strings"
        "time"

        "github.com/go-echarts/go-echarts/v2/charts"
        "github.com/go-echarts/go-echarts/v2/opts"
        "go.uber.org/zap"
)

type DashboardService interface {
        GetDashboardSummary() (*models.Summary, error)
        CurrentMonthEarning() (*models.Revenue, error)
        GenerateRenevueChart() (*bytes.Buffer, error)
        GetBestItemList() ([]models.BestProduct, error)
}

type dashboardService struct {
        Repo repository.Repository
        Log  *zap.Logger
}

// GetDashboardSummary implements DashboardService.
func (d *dashboardService) GetDashboardSummary() (*models.Summary, error) <span class="cov0" title="0">{
        countCustomer, err := d.Repo.User.CountCustomer()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">countTotalOrder, err := d.Repo.Order.CountOrder()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">countTotalProduct, err := d.Repo.Product.CountProduct()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">totalPriceOrder, err := d.Repo.Order.CountTotalPriceOrder()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">summary := &amp;models.Summary{
                TotalUser:    countCustomer,
                TotalOrder:   countTotalOrder,
                TotalProduct: countTotalProduct,
                TotalSales:   totalPriceOrder,
        }
        return summary, nil</span>
}

// CurrentMonthEarning implements DashboardService.
func (d *dashboardService) CurrentMonthEarning() (*models.Revenue, error) <span class="cov0" title="0">{
        // Fetch earnings for each month
        monthlyEarning, err := d.Repo.Order.GetEarningEachMonth()
        if err != nil </span><span class="cov0" title="0">{
                d.Log.Error("Error getting monthly earning", zap.Error(err))
                return nil, err
        }</span>

        // Ensure monthlyEarning is not nil or empty
        <span class="cov0" title="0">if monthlyEarning == nil || len(monthlyEarning) == 0 </span><span class="cov0" title="0">{
                d.Log.Warn("No monthly earning data available")
                return nil, nil
        }</span>

        // Trim spaces from month names to ensure comparison works
        <span class="cov0" title="0">for i := range monthlyEarning </span><span class="cov0" title="0">{
                monthlyEarning[i].Month = strings.TrimSpace(monthlyEarning[i].Month)
        }</span>

        <span class="cov0" title="0">d.Log.Info("Monthly earnings", zap.Any("Earnings", monthlyEarning))

        // Get the current month's name
        currentMonth := time.Now().Format("January")

        // Initialize a variable to store the current month's earnings
        var thisMonthEarning *models.Revenue

        // Ensure the list has an entry for each month from January to December
        months := []string{
                "January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December",
        }

        // Create a map for easy lookup
        earningsMap := make(map[string]float64)
        for _, earning := range monthlyEarning </span><span class="cov0" title="0">{
                earningsMap[earning.Month] = earning.TotalEarning
        }</span>

        // Iterate over months to find the current month and ensure all months are accounted for
        <span class="cov0" title="0">for _, month := range months </span><span class="cov0" title="0">{
                // If there's no data for a specific month, set its earnings to 0
                if _, exists := earningsMap[month]; !exists </span><span class="cov0" title="0">{
                        earningsMap[month] = 0
                }</span>

                <span class="cov0" title="0">if month == currentMonth </span><span class="cov0" title="0">{
                        thisMonthEarning = &amp;models.Revenue{
                                Month:        month,
                                TotalEarning: earningsMap[month],
                        }
                        break</span>
                }
        }

        // Handle case where there's no data for the current month
        <span class="cov0" title="0">if thisMonthEarning == nil </span><span class="cov0" title="0">{
                d.Log.Warn("No earning data found for the current month", zap.String("Month", currentMonth))
                return nil, nil
        }</span>

        <span class="cov0" title="0">return thisMonthEarning, nil</span>
}

// GetBestItemList implements DashboardService.
func (d *dashboardService) GetBestItemList() ([]models.BestProduct, error) <span class="cov0" title="0">{
        return d.Repo.Product.CountEachProduct()
}</span>

// RenevueChart implements DashboardService.
func (d *dashboardService) GenerateRenevueChart() (*bytes.Buffer, error) <span class="cov0" title="0">{
        monthlyEarning, err := d.Repo.Order.GetEarningEachMonth()
        if err != nil </span><span class="cov0" title="0">{
                d.Log.Error("Error getting monthly earning", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">d.Log.Info("Monthly earning", zap.Any("Earning", monthlyEarning))
        // Prepare data for the chart
        xValues := make([]string, len(monthlyEarning))
        yValues := make([]opts.LineData, len(monthlyEarning))

        for i, entry := range monthlyEarning </span><span class="cov0" title="0">{
                xValues[i] = entry.Month
                yValues[i] = opts.LineData{Value: entry.TotalEarning}
        }</span>

        <span class="cov0" title="0">line := charts.NewLine()

        // Set chart options
        line.SetGlobalOptions(
                charts.WithTitleOpts(opts.Title{Title: "Monthly Revenue"}),
                charts.WithXAxisOpts(opts.XAxis{Name: "Month"}),
                charts.WithYAxisOpts(opts.YAxis{Name: "Revenue"}),
        )
        // Set X-axis and add series
        line.SetXAxis(xValues).
                AddSeries("Revenue", yValues).
                SetSeriesOptions(charts.WithLineChartOpts(opts.LineChart{Smooth: opts.Bool(true)})) // Properly cast 'true' to opts.Bool

        // Render the chart into a buffer
        buffer := new(bytes.Buffer)
        if err := line.Render(buffer); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return buffer, nil</span>
}

func NewDashboardService(repo repository.Repository, log *zap.Logger) DashboardService <span class="cov8" title="1">{
        return &amp;dashboardService{Repo: repo, Log: log}
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package dashboardservice

import (
        "bytes"
        "dashboard-ecommerce-team2/models"

        "github.com/stretchr/testify/mock"
)

type MockDashboardService struct {
        mock.Mock
        DashboardService DashboardService
}

func (m *MockDashboardService) GetDashboardSummary() (*models.Summary, error) <span class="cov8" title="1">{
        args := m.Called()
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*models.Summary), args.Error(1)</span>
}

func (m *MockDashboardService) CurrentMonthEarning() (*models.Revenue, error) <span class="cov8" title="1">{
        args := m.Called()
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*models.Revenue), args.Error(1)</span>
}

func (m *MockDashboardService) GenerateRenevueChart() (*bytes.Buffer, error) <span class="cov8" title="1">{
        args := m.Called()
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*bytes.Buffer), args.Error(1)</span>
}

func (m *MockDashboardService) GetBestItemList() ([]models.BestProduct, error) <span class="cov0" title="0">{
        args := m.Called()
        return args.Get(0).([]models.BestProduct), args.Error(1)
}</span>

// NewMockDashboardService is a helper function to create a mock instance
func NewMockDashboardService() *MockDashboardService <span class="cov0" title="0">{
        return &amp;MockDashboardService{}
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package orderservice

import (
        "dashboard-ecommerce-team2/models"
        "dashboard-ecommerce-team2/repository"
        "errors"

        "go.uber.org/zap"
        "gorm.io/gorm"
)

type OrderService interface {
        UpdateOrderStatus(id int, status string) error
        GetAllOrders(page, limit int) ([]models.Order, int64, error)
        GetOrderByID(id int) (*models.Order, error)
        DeleteOrder(id int) error
        GetOrderDetail(id int) (*models.Order, []models.OrderItem, error)
}

type orderService struct {
        Repo repository.Repository
        Log  *zap.Logger
}

// GetAllOrders implements OrderService.
func (o *orderService) GetAllOrders(page, limit int) ([]models.Order, int64, error) <span class="cov0" title="0">{
        o.Log.Info("Fetching paginated orders", zap.Int("page", page), zap.Int("limit", limit))

        // Panggil repository untuk mendapatkan data dengan pagination
        orders, totalItems, err := o.Repo.Order.GetAll(page, limit)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error("Failed to fetch paginated orders", zap.Error(err))
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return orders, totalItems, nil</span>
}

// GetOrderByID implements OrderService.
func (o *orderService) GetOrderByID(id int) (*models.Order, error) <span class="cov0" title="0">{
        o.Log.Info("Fetching order by ID", zap.Int("id", id))
        order, err := o.Repo.Order.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        o.Log.Warn("Order not found", zap.Int("id", id))
                        return nil, errors.New("order not found")
                }</span>
                <span class="cov0" title="0">o.Log.Error("Failed to fetch order", zap.Error(err))
                return nil, err</span>
        }
        <span class="cov0" title="0">return order, nil</span>
}

// UpdateOrderStatus implements OrderService.
func (o *orderService) UpdateOrderStatus(id int, status string) error <span class="cov0" title="0">{
        o.Log.Info("Updating order status", zap.Int("id", id), zap.String("status", status))
        order, err := o.Repo.Order.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        o.Log.Warn("Order not found", zap.Int("id", id))
                        return errors.New("order not found")
                }</span>
                <span class="cov0" title="0">o.Log.Error("Failed to fetch order", zap.Error(err))
                return err</span>
        }

        <span class="cov0" title="0">order.Status = status
        if err := o.Repo.Order.UpdateStatus(id, status); err != nil </span><span class="cov0" title="0">{
                o.Log.Error("Failed to update order status", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">o.Log.Info("Order status updated successfully", zap.Int("id", id), zap.String("status", status))
        return nil</span>
}

func (o *orderService) DeleteOrder(id int) error <span class="cov0" title="0">{
        o.Log.Info("Deleting order", zap.Int("id", id))
        err := o.Repo.Order.DeleteOrder(id)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error("Failed to delete order", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">o.Log.Info("Order deleted successfully", zap.Int("id", id))
        return nil</span>
}

func (o *orderService) GetOrderDetail(id int) (*models.Order, []models.OrderItem, error) <span class="cov0" title="0">{
        o.Log.Info("Fetching order details", zap.Int("id", id))
        order, orderItems, err := o.Repo.Order.GetDetail(id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        o.Log.Warn("Order not found", zap.Int("id", id))
                        return nil, nil, errors.New("order not found")
                }</span>
                <span class="cov0" title="0">o.Log.Error("Failed to fetch order details", zap.Error(err))
                return nil, nil, err</span>
        }
        <span class="cov0" title="0">return order, orderItems, nil</span>
}

func NewOrderService(repo repository.Repository, log *zap.Logger) OrderService <span class="cov8" title="1">{
        return &amp;orderService{Repo: repo, Log: log}
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package productservice

import (
        "dashboard-ecommerce-team2/models"
        "dashboard-ecommerce-team2/repository"
        utils "dashboard-ecommerce-team2/util"
        "errors"
        "os"

        "go.uber.org/zap"
)

type ProductService interface {
        CreateProduct(product *models.Product, filePath string) (*models.Product, error)
        GetAllProducts(page, pageSize int) ([]*models.ProductWithCategory, int, error)
        GetProductByID(id int) (*models.ProductID, error)
        UpdateProduct(id int, product models.Product, filePath string) (*models.Product, error)
        DeleteProduct(id int) error
}

type productService struct {
        Repo repository.Repository
        Log  *zap.Logger
}

// CreateProduct implements ProductService.
func (p *productService) CreateProduct(product *models.Product, filePath string) (*models.Product, error) <span class="cov0" title="0">{
        cdnURL, err := utils.UploadToCDN(filePath)
        if err != nil </span><span class="cov0" title="0">{
                p.Log.Error("service: upload failed", zap.Error(err))
                return product, err
        }</span>

        <span class="cov0" title="0">product.Images = []string{cdnURL}

        if err := p.Repo.Product.Create(product); err != nil </span><span class="cov0" title="0">{
                p.Log.Error("service: create failed", zap.Error(err))
                return product, err
        }</span>

        <span class="cov0" title="0">os.Remove(filePath)

        return product, nil</span>
}

// DeleteProduct implements ProductService.
func (p *productService) DeleteProduct(id int) error <span class="cov0" title="0">{
        err := p.Repo.Product.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to delete product")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetAllProducts implements ProductService.
func (p *productService) GetAllProducts(page, pageSize int) ([]*models.ProductWithCategory, int, error) <span class="cov0" title="0">{
        products, totalItems, err := p.Repo.Product.GetAll(page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">if len(products) == 0 </span><span class="cov0" title="0">{
                return nil, int(totalItems), errors.New("product not found")
        }</span>
        // Convert totalItems from int64 to int before returning
        <span class="cov0" title="0">return products, int(totalItems), nil</span>
}

// GetProductByID implements ProductService.
func (p *productService) GetProductByID(id int) (*models.ProductID, error) <span class="cov0" title="0">{
        product, err := p.Repo.Product.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("product not found")
        }</span>
        <span class="cov0" title="0">return product, nil</span>
}

// UpdateProduct implements ProductService.
func (p *productService) UpdateProduct(id int, product models.Product, filePath string) (*models.Product, error) <span class="cov0" title="0">{
        if filePath != "" </span><span class="cov0" title="0">{
        cdnURL, err := utils.UploadToCDN(filePath)
        if err != nil </span><span class="cov0" title="0">{
            p.Log.Error("service: upload failed", zap.Error(err))
            return nil, err
        }</span>
        <span class="cov0" title="0">product.Images = []string{cdnURL}</span>
    }

    <span class="cov0" title="0">updatedProduct, err := p.Repo.Product.Update(id, product)
    if err != nil </span><span class="cov0" title="0">{
        p.Log.Error("service: update failed", zap.Error(err))
        return nil, err
    }</span>

    <span class="cov0" title="0">os.Remove(filePath) 
    return updatedProduct, nil</span>
}

func NewProductService(repo repository.Repository, log *zap.Logger) ProductService <span class="cov8" title="1">{
        return &amp;productService{Repo: repo, Log: log}
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package promotionservice

import (
        "dashboard-ecommerce-team2/models"
        "dashboard-ecommerce-team2/repository"

        "go.uber.org/zap"
)

type PromotionService interface {
        GetAllPromotions() ([]models.Promotion, error)
        CreatePromotion(promoInput *models.Promotion) error
        UpdatePromotion(promoInput *models.Promotion) error
        DeletePromotion(id int) error
        GetByIDPromotion(id int) (*models.Promotion, error)
}

type promotionService struct {
        Repo repository.Repository
        Log  *zap.Logger
}

// CreatePromotion implements PromotionService.
func (p *promotionService) CreatePromotion(promoInput *models.Promotion) error <span class="cov0" title="0">{
        return p.Repo.Promotion.Create(promoInput)
}</span>

// DeletePromotion implements PromotionService.
func (p *promotionService) DeletePromotion(id int) error <span class="cov0" title="0">{
        return p.Repo.Promotion.Delete(id)
}</span>

// GetAllPromotions implements PromotionService.
func (p *promotionService) GetAllPromotions() ([]models.Promotion, error) <span class="cov0" title="0">{
        return p.Repo.Promotion.GetAll()
}</span>

// GetByIdPromotion implements PromotionService.
func (p *promotionService) GetByIDPromotion(id int) (*models.Promotion, error) <span class="cov0" title="0">{
        return p.Repo.Promotion.GetByID(id)
}</span>

// UpdatePromotion implements PromotionService.
func (p *promotionService) UpdatePromotion(promoInput *models.Promotion) error <span class="cov0" title="0">{
        return p.Repo.Promotion.Update(promoInput)
}</span>

func NewPromotionService(repo repository.Repository, log *zap.Logger) PromotionService <span class="cov8" title="1">{
        return &amp;promotionService{Repo: repo, Log: log}
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package service

import (
        "dashboard-ecommerce-team2/repository"
        bannerservice "dashboard-ecommerce-team2/service/banner"
        categoryservice "dashboard-ecommerce-team2/service/category"
        dashboardservice "dashboard-ecommerce-team2/service/dashboard"
        orderservice "dashboard-ecommerce-team2/service/order"
        productservice "dashboard-ecommerce-team2/service/product"
        promotionservice "dashboard-ecommerce-team2/service/promotion"
        stockservice "dashboard-ecommerce-team2/service/stock"
        userservice "dashboard-ecommerce-team2/service/user"

        "go.uber.org/zap"
)

type Service struct {
        Banner    bannerservice.BannerService
        Category  categoryservice.CategoryService
        Dashboard dashboardservice.DashboardService
        Order     orderservice.OrderService
        Product   productservice.ProductService
        Promotion promotionservice.PromotionService
        Stock     stockservice.StockService
        User      userservice.UserService
}

func NewService(repo repository.Repository, log *zap.Logger) Service <span class="cov8" title="1">{
        return Service{
                Banner:    bannerservice.NewBannerService(repo, log),
                Category:  categoryservice.NewCategoryService(repo, log),
                Dashboard: dashboardservice.NewDashboardService(repo, log),
                Order:     orderservice.NewOrderService(repo, log),
                Product:   productservice.NewProductService(repo, log),
                Promotion: promotionservice.NewPromotionService(repo, log),
                Stock:     stockservice.NewStockService(repo, log),
                User:      userservice.NewUserService(repo, log),
        }
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package stockservice

import (
        "dashboard-ecommerce-team2/models"
        "dashboard-ecommerce-team2/repository"
        "errors"
        "fmt"

        "go.uber.org/zap"
)

type StockService interface {
        UpdateProductStock(stockHistory *models.StockRequest) error
        GetProductStockDetail(id int) (*models.StockResponse, error)
        DeleteProductStock(id int) error
}

type stockService struct {
        Repo repository.Repository
        Log  *zap.Logger
}

// DeleteProductStock implements StockService.
func (s *stockService) DeleteProductStock(id int) error <span class="cov0" title="0">{
        err := s.Repo.Stock.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to delete product")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetProductStockDetail implements StockService.
func (s *stockService) GetProductStockDetail(id int) (*models.StockResponse, error) <span class="cov0" title="0">{
        stockHistory, err := s.Repo.Stock.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get history: %w", err)
        }</span>
        <span class="cov0" title="0">return stockHistory, nil</span>
}

// UpdateProductStock implements StockService.
func (s *stockService) UpdateProductStock(stockHistory *models.StockRequest) error <span class="cov0" title="0">{
        if err := s.Repo.Stock.Update(stockHistory); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update stock: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func NewStockService(repo repository.Repository, log *zap.Logger) StockService <span class="cov8" title="1">{
        return &amp;stockService{Repo: repo, Log: log}
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package userservice

import (
        "dashboard-ecommerce-team2/helper"
        "dashboard-ecommerce-team2/models"
        "dashboard-ecommerce-team2/repository"
        "errors"

        "go.uber.org/zap"
)

type UserService interface {
        CreateUser(userInput models.RegisterRequest) error
        Login(input models.LoginRequest) (*models.User, error)
        CheckUserEmail(email string) (*models.User, error)
        ResetUserPassword(input models.LoginRequest) error
}

type userService struct {
        Repo repository.Repository
        Log  *zap.Logger
}

// CheckUserEmail implements UserService.
func (u *userService) CheckUserEmail(email string) (*models.User, error) <span class="cov8" title="1">{
        return u.Repo.User.GetByEmail(email)
}</span>

// CreateUser implements UserService.
func (u *userService) CreateUser(userInput models.RegisterRequest) error <span class="cov8" title="1">{
        newUserInput := models.User{
                Email:    userInput.Email,
                Password: helper.HashPassword(userInput.Password),
                Role:     "staff",
                Name:     userInput.Name,
        }
        return u.Repo.User.Create(newUserInput)
}</span>

// Login implements UserService.
func (u *userService) Login(input models.LoginRequest) (*models.User, error) <span class="cov8" title="1">{
        user, err := u.Repo.User.GetByEmail(input.Email)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        // Check if the user's password matches the input password
        <span class="cov8" title="1">if !helper.CheckPassword(input.Password, user.Password) </span><span class="cov8" title="1">{
                return nil, errors.New("invalid user password")
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}

// ResetUserPassword implements UserService.
func (u *userService) ResetUserPassword(input models.LoginRequest) error <span class="cov8" title="1">{
        resetPassword := models.LoginRequest{
                Email:    input.Email,
                Password: helper.HashPassword(input.Password),
        }
        return u.Repo.User.UpdatePassword(resetPassword)
}</span>

func NewUserService(repo repository.Repository, log *zap.Logger) UserService <span class="cov0" title="0">{
        return &amp;userService{Repo: repo, Log: log}
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package userservice

import (
        "dashboard-ecommerce-team2/models"

        "github.com/stretchr/testify/mock"
)

type MockService struct {
        mock.Mock
        UserService UserService
}

func (m *MockService) User() UserService <span class="cov0" title="0">{
        args := m.Called()
        return args.Get(0).(UserService)
}</span>

type MockUserService struct {
        mock.Mock
}

func (m *MockUserService) CreateUser(registerReq models.RegisterRequest) error <span class="cov0" title="0">{
        args := m.Called(registerReq)
        return args.Error(0)
}</span>

// Login provides a mock function with given arguments
func (m *MockUserService) Login(input models.LoginRequest) (*models.User, error) <span class="cov0" title="0">{
        args := m.Called(input)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*models.User), args.Error(1)</span>
}

// CheckUserEmail provides a mock function with given arguments
func (m *MockUserService) CheckUserEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        args := m.Called(email)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*models.User), args.Error(1)</span>
}

// ResetUserPassword provides a mock function with given arguments
func (m *MockUserService) ResetUserPassword(input models.LoginRequest) error <span class="cov0" title="0">{
        args := m.Called(input)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package utils

import (
        "dashboard-ecommerce-team2/models"

        "github.com/stretchr/testify/mock"
)

type Service struct {
        Banner *BannerService
}

type BannerService struct {
        mock.Mock
}

func (m *BannerService) CreateBanner(banner *models.Banner) error <span class="cov0" title="0">{
        args := m.Called(banner)
        return args.Error(0)
}</span>

func (m *BannerService) GetBannerByID(id int) (*models.Banner, error) <span class="cov0" title="0">{
        args := m.Called(id)
        if banner, ok := args.Get(0).(*models.Banner); ok </span><span class="cov0" title="0">{
                return banner, args.Error(1)
        }</span>
        <span class="cov0" title="0">return nil, args.Error(1)</span>
}

func (m *BannerService) UpdateBanner(banner models.Banner) error <span class="cov0" title="0">{
        args := m.Called(banner)
        return args.Error(0)
}</span>

func (m *BannerService) DeleteBanner(id int) error <span class="cov0" title="0">{
        args := m.Called(id)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package utils

import (
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "time"

        "github.com/go-resty/resty/v2"
)

func UploadToCDN(filePath string) (string, error) <span class="cov0" title="0">{
        fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov0" title="0">if fileInfo.Size() &gt; 1*1024*1024 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("file size exceeds limit: %d bytes", fileInfo.Size())
        }</span>

        <span class="cov0" title="0">cdnURL := os.Getenv("CDN_API_URL")
        if cdnURL == "" </span><span class="cov0" title="0">{
                return "", errors.New("CDN_API_URL is not set")
        }</span>

        // Inisialisasi Resty client dengan timeout dan mekanisme retry
        <span class="cov0" title="0">client := resty.New().
                SetTimeout(10 * time.Second). // Batas waktu 10 detik
                SetRetryCount(3).             // Maksimal 3 percobaan ulang
                SetRetryWaitTime(2 * time.Second).
                SetRetryMaxWaitTime(10 * time.Second)


        // Kirim file ke CDN API
        resp, err := client.R().
                SetFile("image", filePath).
                Post(cdnURL) // Gunakan CDN URL langsung


        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to upload file: %w", err)
        }</span>

        // Validasi status HTTP response
        <span class="cov0" title="0">if resp.StatusCode() != 200 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("upload failed with status: %d, response: %s", resp.StatusCode(), resp.String())
        }</span>

        // Parsing JSON respons sesuai struktur
        <span class="cov0" title="0">var result struct {
                Data    struct {
                        URL string `json:"url"`
                } `json:"data"`
        }
        
        if err := json.Unmarshal(resp.Body(), &amp;result); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse CDN response: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println("result: ", result)

        // Validasi apakah URL tersedia di dalam data
        if result.Data.URL == "" </span><span class="cov0" title="0">{
                return "", errors.New("CDN response missing 'url' field")
        }</span>

        <span class="cov0" title="0">return result.Data.URL, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
